---
title: 中文版 1-4
slug: >-
  X5HAwhUxHixmzTkqv9BcS22Cn6c/BBEOwHkYViRIM1kzyxHc8iKgnMc/H4iRwSI2EiFpszkRPBfcwEian4b
sidebar_position: 0
---


# 中文版 1-4

# 超文本、互联网和万维网

## 层次结构与网络结构

为了理解您提供的关于<b>学习目标1.1</b>的段落，我们需要考察讲座如何将传统的知识组织方法（层级结构）与网络和语义网的基本架构（网络结构）进行对比。

根据提供的资料，以下是对如何解读这一区别的详细分析：

### 层次结构（“树”模型）

文章将此描述为“自上而下”，即概念从父节点分支出来。

- <b>如何理解它：</b>想象一个实体图书馆或文件柜。你从一个宽泛的主题开始，然后逐步缩小范围。一个特定的条目通常在系统中只有一个“正确”的位置。
- <b>讲座示例（万国文献馆）：</b>资料通过<b>保罗·奥特莱的万国文献馆</b>来说明这一点。
    - 奥特莱尝试使用严格的通用十进制分类系统来组织所有人类知识。
    - 正如讲座幻灯片中所示，这一流程源自《宇宙》$\rightarrow$《科学》$\rightarrow$《书籍》$\rightarrow$《参考文献》。
    - 这代表了一种对世界的僵化看法，即知识被分类到不同的“桶”中。

- <b>技术示例（DNS）：</b>讲座还以<b>域名系统（DNS）</b>为例，说明层次结构。像`www.example.org`这样的域名会按层次结构映射到一个由互联网号码分配机构（IANA）管理的IP地址。
    
### 网络结构（“图”模型）

文章将其描述为一个带有节点和箭头（边）的“有向图”。

- <b>如何理解它：</b>想象一下大脑或蜘蛛网。任何想法都可以直接与其他任何想法相连，无需经过一个中心类别。没有“顶部”或“底部”。
- <b>历史背景：</b>
    - <b>万尼瓦尔·布什（麦克斯存储器）：</b>布什批评了传统的索引（层级结构），并提出了“关联索引”，即把条目关联在一起，以便一个条目能立即唤起另一个条目。
    - <b>泰德·尼尔森：</b>创造了“超文本”一词，并强调“万物皆深度交织”。在网络中，连接比分类更重要。

- <b>梅特卡夫定律：</b>网络结构（如互联网）的价值会随着更多节点（设备/人员）的加入而呈指数级增长（$N^2$），因为可能的连接数量会迅速增加。
- <b>技术示例（RDF）：</b>文章提到了RDF（资源描述框架）。来源证实，“数据网”依赖于访问<b>链接数据</b>和构建<b>RDF数据集</b>。在RDF中，信息不存储在树上，而是作为“三元组”（$\rightarrow$主谓$\rightarrow$对象），形成一个巨大的、相互连接的图。
    
### 区别总结

“理解这段话”意味着认识到我们管理信息方式的转变：

<table>
<colgroup>
<col width="200"/>
<col width="200"/>
<col width="200"/>
</colgroup>
<tbody>
<tr><td><p>功能</p></td><td><p>层级结构</p></td><td><p>网络结构</p></td></tr>
<tr><td><p><b>形状</b></p></td><td><p>树形 / 金字塔形</p></td><td><p>Web / Mesh</p></td></tr>
<tr><td><p><b>移动</b></p></td><td><p>自上而下（从一般到具体）</p></td><td><p>关联（节点到节点）</p></td></tr>
<tr><td><p><b>关键人物</b></p></td><td><p>保罗·奥特莱（世界文献馆）</p></td><td><p>万尼瓦尔·布什（Memex）、蒂姆·伯纳斯 - 李</p></td></tr>
<tr><td><p><b>示例</b></p></td><td><p>文件目录、DNS</p></td><td><p>超文本，RDF图</p></td></tr>
</tbody>
</table>

<b>关键洞察：</b>该讲座追溯了信息的历史，从僵化的<b>层级结构</b>（如万维文献馆）到灵活的<b>网络</b>（万维网），最后到<b>语义网</b>，语义网将这种网络结构应用于数据本身（使用RDF）。

## 基础互联网和网络技术及其关系

根据提供的讲座幻灯片，以下是关于基本互联网和网络技术及其相互关系的详细大纲。

### 互联网：基础设施

互联网是数据交换的底层全球网络基础设施。其发展是分散式的，由特定组织和标准进行管理，以确保互操作性。

- <b>治理与标准化：</b>
    - <b>互联网工程任务组（IETF）：</b>该组织管理着被称为<b>征求意见稿（RFC）</b>的技术规范。这些文件描述了互联网操作系统的基本协议和概念。
    - <b>互联网名称与数字地址分配机构（ICANN）：</b>一家非营利性公司，负责管理互联网的逻辑，包括IP地址分配和域名系统（DNS）管理。
    - <b>互联网号码分配机构（IANA）：</b>互联网名称与数字地址分配机构（ICANN）的一个部门，负责协调IP分配和管理DNS。
        
- <b>关键互联网技术（协议）：</b>
    - <b>IP（互联网协议）：</b>在RFC 791中定义，它负责在网络中对设备进行寻址和发送数据包。
    - <b>TCP（传输控制协议）：</b>在RFC 793中定义，它将数据拆分为数据包以符合IP要求。
    - <b>DNS（域名系统）：</b>一种分层组织的系统，它将人类可读的主机名（例如`www.example.org`）映射到机器可读的IP地址（例如`198.51.100.38`）。
        
- <b>关键原则：</b>
    - <b>健壮：</b>“自己做事要保守，接受别人的要宽松”。
    - <b>梅特卡夫定律（网络效应）：</b>网络的价值与连接用户数量的平方成正比（$N^2$），这意味着随着更多设备/用户的加入，网络的价值呈指数级增长。
        
---

### 万维网：应用层

万维网（WWW）是一个分布式、协作式信息系统，它运行在<b>互联网基础设施之上</b>。蒂姆·伯纳斯 - 李设想它来帮助分析信息和进行协作。

- <b>治理：</b>
    - <b>万维网联盟（W3C）：</b>由蒂姆·伯纳斯 - 李领导，这个国际组织制定网络标准（推荐标准），以确保网络的长期发展。
        
- <b>核心网络技术（“三位一体”）：</b>

网络依赖于由W3C和IETF标准定义的三大支柱：
1. <b>URI（统一资源标识符）：</b>
    - <b>定义：</b>标识<b>资源</b>的字符序列。“资源”可以是任何事物：电子文档、图像、实物或抽象概念。
    - <b>结构：</b>根据RFC 3986的定义，URI通常由方案（例如`http`）、权限（服务器）、路径、查询和片段组成。
    - <b>区别：</b>区分事物的<em>名称</em>（URI）和<em>事物</em>本身（资源）至关重要。
        2. <b>HTTP（超文本传输协议）：</b>
    - <b>定义：</b>一种<b>无状态</b>的应用层信息交换协议。“无状态”指的是，除非使用特定的会话管理（如 Cookie），否则服务器会独立处理每一次交互。
    - <b>交互方式：</b>它基于请求/响应模型运行。<b>用户代理</b>（例如浏览器）发送请求，<b>服务器</b>则以响应进行回复。
    - <b>组成部分：</b>消息包括起始行（方法或状态码）、头部字段（元数据）和可选的消息体（内容）。
    - <b>内容协商：</b>像`Accept`这样的机制允许用户代理请求特定格式（例如，HTML、JSON、RDF），服务器会尝试提供最佳匹配。
        3. <b>HTML（超文本标记语言）：</b>
    - <b>功能：</b>一种用于表示文档结构（标题、段落）的语言，最重要的是，用于<b>链接</b>到其他文档的超链接。
    - <b>发展历程：</b>它从IETF的RFC（HTML 2.0）发展到W3C的推荐标准（HTML 3.2、4.0），现在由WHATWG作为“现行标准”进行维护。
        
---

### 互联网与万维网的关系

这种关系可以描述为<b>基础设施与应用程序</b>。

1. <b>依赖关系：</b>互联网是网络基础。万维网是利用这一基础来运行的应用程序。
    - 网络使用<b>互联网协议</b>来传输数据：HTTP（网络协议）依赖TCP（互联网协议）将数据拆分为数据包，而TCP又依赖IP（互联网协议）来为这些数据包寻址。
    - Web 使用<b> DNS </b>（互联网服务）来定位托管 Web 资源的服务器。
        
2. <b>架构：</b>
    - <b>互联网模型：</b>侧重于通过电缆和信号连接计算机和设备（节点）。
    - <b>网络模型：</b>侧重于通过超链接连接<b>文档和资源</b>。互联网连接机器，而网络连接信息。
        
3. <b>治理：</b>
    - 互联网主要由<b>互联网工程任务组（IETF）</b>进行标准化（专注于像TCP/IP这样的“管道”）。
    - 网络的标准化主要由<b>万维网联盟（W3C）</b>（专注于内容和呈现，如HTML、XML和架构）负责。
        
<b>总结：</b>你可以将互联网视为“轨道”（基础设施），而万维网则是在其上运行的“列车”（服务）。万维网利用互联网的连接性，创建了一个全球互联的信息空间。

## 评估信息系统架构中去中心化的特征

根据提供的讲座内容，特别是<b>学习目标1.3</b>（“评估信息系统架构中去中心化的特征”），以下是使用资料中的历史和技术背景对您列出的三个特征（健壮性、可扩展性和降低延迟）的详细解释。

### 稳健性：通过去中心化实现弹性

用户定义强调“无单点故障”。讲座通过将去中心化网络与中心化的历史模型进行对比，并引入可靠性的技术原则来支持这一点。

- <b>避免中心瓶颈：</b>讲座将网络与<b>保罗·奥特莱的世界文献馆</b>（20世纪10年代）进行了对比，后者试图使用严格的层级分类法将所有知识集中在一个单一的物理地点（“世界城市”）。去中心化架构消除了此类中心故障点。网络允许<b>“无需许可的创新”</b>，即无需中央权威机构审查或批准变更，从而防止官僚主义瓶颈阻碍系统发展。
- <b>波斯特尔稳健：</b>为确保在众多不同系统相互交互的去中心化环境中的可靠性，互联网依赖于<b>乔恩·波斯特尔的稳健</b>（RFC 793）：*“自己做事要保守，接受他人的要宽松”*。这确保了即使一个节点（例如，服务器）发送的是不完美的数据，接收节点（例如，浏览器）也会尝试处理它，而不是中断连接，从而维持网络的整体弹性。

### 增强的可扩展性：适应增长

用户定义提到通过添加节点来适应增长。资料明确指出了使网络能够无限扩展的技术和经济因素。

- <b>技术可扩展性（无反向链接）：</b>实现Web可扩展性的一个关键架构决策是采用<b>单向链接</b>。课程讲义指出，“不存在增长可扩展性问题（例如，HTML页面没有反向链接）”。在以前的超文本系统（如泰德·尼尔森的<b>仙那度</b>）中，链接通常是双向的，需要一个中央数据库来跟踪连接。通过消除这一需求，Web允许独立添加节点，而无需更新中央注册表。
- <b>经济可扩展性（梅特卡夫定律）：</b>讲座引用了<b>梅特卡夫定律</b>，该定律指出，虽然网络成本随设备数量呈线性增长（$N$），但网络的<b>价值</b>呈指数级增长（$N^2$）。这种“正反馈循环”激励着不断添加新节点，推动网络的去中心化扩展。
    
### 降低延迟：数据处理更贴近用户

用户定义指的是更靠近用户的处理过程。虽然讲座没有明确讨论“边缘计算”，但它描述了HTTP中促进这一过程的架构机制。

- <b>HTTP缓存：</b>讲座强调<b>RFC 9111（HTTP缓存）</b>是Web架构的核心组成部分。缓存允许<b>用户代理</b>（浏览器）或中间节点在本地存储资源副本。这意味着对相同数据的后续请求可以从本地缓存提供，而无需遍历整个网络来访问源服务器，从而显著减少响应时间。
- <b>无状态交互：</b>HTTP被定义为<b>无状态</b>协议。由于服务器无需为每个用户维护持续且占用大量资源的连接状态，因此可以更快、更高效地处理请求。这种设计支持Web的分布式特性，即按需获取资源，而非通过永久线路获取。
    
### 摘要

在本课程的语境中，<b>去中心化</b>不仅仅关乎硬件位置；它由特定的<b>标准</b>（如HTTP和统一资源标识符）所支持，这些标准允许不同的系统在没有中央控制器的情况下进行协作。这种<b>健壮的协议</b>（Postel原则）、<b>可扩展的设计选择</b>（无反向链接）和<b>性能优化</b>（缓存）的结合，造就了你查询中所描述的架构。

## 解释梅特卡夫定律所表达的网络效应

根据提供的讲座材料，以下是对<b>梅特卡夫定律</b>和<b>网络效应</b>的解释，这些内容在<b>学习目标1.4</b>中有所描述。

### 核心概念：线性成本与指数价值

你引用的段落将<b>建设网络的成本</b>与<b>从中获得的价值</b>进行了对比。

- <b>成本（</b>$N$<b>）：线性增长</b>

根据讲座内容，梅特卡夫的理论最初是基于<b>网卡</b>（硬件）的销售。如果你在网络中增加一个新用户，就需要购买一张新的网卡。因此，成本与用户数量呈线性增长（$N$）。如果你有100个用户，成本大约是一个用户成本的100倍。

- <b>价值（</b>$N^2$<b>）：指数增长</b>

网络的价值并非呈线性增长，而是呈指数级增长。这是因为“价值”是由<b>用户之间的潜在连接</b>所定义的。
- 在一个由2人组成的网络中，只可能存在1条连接。
- 在一个由5人组成的网络中，可能存在10种连接。
- 随着$N$的增加，可能的通信对数量大致按用户数量的平方增长（$N^2$）。因此，一旦有新用户加入，网络对<em>所有</em>相关人员的价值就会显著提升。
    
### 临界质量交叉

讲座幻灯片中包含一张说明这种关系的图表。

- 在开始阶段（用户极少时），<b>成本</b>（直线）高于<b>价值</b>（曲线）。
- 然而，由于$N^2$的增长速度远快于$N$，两条线最终会相交。这个交点被标记为<b>"临界质量交叉点"</b>。
- 一旦一个网络达到这个“临界规模”，网络的效用/价值就会超过加入它的成本。这一点对于像互联网这样的技术的成功至关重要。
    
### 应用于网络（正反馈循环）

该讲座将梅特卡夫定律与万维网的成功联系起来。

- <b>正反馈循环：</b>由于价值随参与者数量的增加而增长，早期采用引发了一个循环，即高价值吸引了更多用户，而这反过来又创造了更多价值。
- <b>可扩展性：</b>这一经济原则与网络的技术可扩展性（如不存在中央瓶颈或“无需许可的创新”）协同作用，使网络得以发展成为如今的全球系统。
    
<b>总结：</b>要理解这段话，需认识到虽然<em>扩展的成本</em>很直接（多一个设备 = 多一个单位的成本），但<em>收益</em>是成倍增长的，因为每个新用户都会为每个现有用户创造新的连接可能性。

## 识别并命名资源；根据文本描述区分信息资源与其他资源

根据提供的讲座幻灯片，以下是对<b>学习目标1.5</b>的详细解释，该目标涵盖资源的识别、信息资源与非信息资源的区别以及统一资源标识符（URI）的语法。

### 什么是资源？

在网络架构的语境中，<b>资源</b>被宽泛地定义为“话语对象的抽象概念”。这意味着资源几乎可以是我们想要谈论或引用的任何事物。

- <b>抽象与具体：</b>资源可以是虚拟的（如网站）或实体的（如建筑物）。
- <b>关键区别：</b>讲座明确区分了基于性质的两种资源类型：
    1. <b>信息资源：</b>这些资源可以作为字节流进行数字传输。
        - <i>示例：</i>电子文档、图像、文件和网页。保罗·奥特莱将这些称为“书籍”。
    2. <b>其他（非信息）资源：</b>这些是无法通过电子方式传输的事物。
        - <i>示例：</i>现实世界中的物体（例如“房间”“人”）、抽象概念（例如“化学元素”“数值”）或奥特莱的“思维框架”。
            
<b>关键要点：</b>你必须区分事物的<b>名称</b>（URI）和<b>事物本身</b>（资源）。例如，大学中的一个实体房间是一个*非信息资源*，但该房间的 URI 可能会将你重定向到一个包含该房间日程安排的网页（一个*信息资源*）。

### 什么是 URI？

A <b>统一资源标识符 (URI)</b>是用于唯一标识资源的字符序列。它充当资源的“名称”。

- <b>标准：</b>语法在<b>RFC 3986</b>（互联网标准）中定义。
- <b>功能：</b> URI使我们能够在同一全球系统中引用信息资源（我们可以下载）和非信息资源（我们只能描述）。
    
### 详细的 URI 语法解析

本讲座提供了构建 URI 的具体公式。以下是对示例`http://example.com:8042/over/there?name=ferret#nose`中各组成部分的详细解释：

#### 方案

- <b>定义：</b>指定 URI 的类型，通常还指定用于访问它的关联协议。
- <b>示例：</b> `http`（超文本传输协议），`ftp`，`mailto`，`tel`（电话）。
- <b>在您的字符串中：</b> `http`
    
#### 分层部分

这部分通常以`//`开头，并分为<b>权限</b>和<b>路径</b>。

1. <b>权限：</b>
    - <b>定义：</b>标识命名空间的管理实体，通常是一个<b>主机名</b>（域名）和一个可选的<b>端口号</b>。
    - <b>在您的字符串中：</b> `example.com:8042` （主机：`example.com`，端口：`8042`）。

2. <b>路径：</b>
    - <b>定义：</b>对主机服务器上特定内容的引用。它以分层方式进行解释，类似于计算机上的文件目录树（例如，文件夹中的文件夹）。
    - <b>在你的字符串中：</b> `/over/there`
        
#### 查询（可选）

- <b>定义：</b>包含<em>不</em>符合层次树结构的数据。它通常由用于向数据库或应用程序传递参数的变量/值对组成。
- <b>语法：</b>它前面有一个问号`?`。
- <b>在你的字符串中：</b> `?name=ferret`（变量`name`等于`ferret`）。
    
#### 片段（可选）

- <b>定义：</b>指向检索到的文档中特定的局部部分（如章节标题或页面上的锚点）。
- <b>语法：</b>它前面有一个井号`#`。
- <b>在你的字符串中：</b> `#nose`（指位于`/over/there`的文档中标记为“nose”的部分）。
    
### 摘要

"识别并命名资源" 意味着为一个概念分配一个 <b>URI</b>。"区分它们" 则是要认识到，虽然像 `http://example.org/my-photo.jpg` 这样的 URI 标识的是一个文件（信息资源），但像 `http://example.org/person/Einstein` 这样的 URI 标识的是一个人（非信息资源），尽管两者看起来都像网址。

# 关联数据基础

1. <b>RDF 基础 (01-RDF-Intro)</b>

- <b>背景与动机</b>：介绍了从 Web 1.0（只读）到 Web 2.0（读写）再到 Web 3.0（语义网/数据网）的演变，强调了机器可理解数据的重要性。
- <b>数据模型对比</b>：对比了关系型数据库（结构化）、XML（半结构化树状）和 RDF（半结构化图状）的区别，指出 RDF 适合通过 URI 进行全球数据集成。
- <b>RDF 核心组件</b>：
    - <b>三元组 (Triple)</b>：主语 (Subject) - 谓语 (Predicate) - 宾语 (Object)。
    - <b>IRI</b>：用于全球唯一标识资源，取代了本地 ID。
    - <b>字面量 (Literals)</b>：包含数据类型（如 `xsd:integer`）和语言标签（如 `@de`）。
    - <b>空白节点 (Blank Nodes)</b>：用于表示存在但无需全球标识的资源（如地址或复杂的嵌套结构）。
        
1. <b>Turtle 语法详解 (02-RDF-Turtle)</b>

- <b>基本语法</b>：Turtle (Terse RDF Triple Language) 是一种紧凑的文本格式。
- <b>简写机制</b>：
    - <b>前缀 (Prefixes)</b>：如 `@prefix dbr: <...>` 用于缩短 IRI。
    - <b>谓语简写</b>：关键字 `a` 代表 `rdf:type`。
    - <b>结构简写</b>：分号 `;` 用于同一主语的不同属性，逗号 `,` 用于同一属性的不同值。

- <b>复杂结构</b>：
    - <b>空白节点</b>：可以使用 `_:` 命名，也可以使用方括号 `[]` 表示匿名嵌套结构。
    - <b>集合 (Collections/Lists)</b>：使用圆括号 `( ... )` 表示有序列表，底层通过 `rdf:first`/`rdf:rest`/`rdf:nil` 实现。
        
1. <b>JSON-LD 介绍 (02a-RDF-JSON)</b>

- <b>设计目标</b>：在不破坏现有 JSON 格式的前提下增加语义（Linked Data），解决不同系统间数据定义不一致的“巴别塔”问题。
- <b>核心关键字</b>：
    - <b>@context</b>：将 JSON 的键（key）映射到通过 IRI 定义的词汇表（如 schema.org）。
    - <b>@id</b>：赋予资源唯一的全球标识符。
    - <b>@type</b>：定义资源的类型。

- <b>使用方式</b>：上下文可以内嵌在文档中，也可以通过外部文件引用，甚至可以通过 HTTP Link Header 提供。

## 数据模型

根据提供的讲座幻灯片，以下是对<b>数据模型</b>（学习目标2.1）的详细解释。

### 什么是数据模型？

数据模型是一种<b>形式化方法</b>，用于描述数据库中的对象以及它们之间的关系。本质上，数据模型定义了<b>数据库模式</b>（数据组织方式的蓝图）。数据模型在数据库系统的概念层和外部层都至关重要。

每个数据模型都包含三个核心方面：

- <b>结构：</b>这定义了对象的类型以及它们之间的关系（例如，表和外键，或节点和边）。
- <b>操作：</b>这些是用于<b>数据提取和链接</b>的机制。它们与查询语言有着内在的联系。例如，<b>SQL</b>用于关系模型，而<b>SPARQL</b>是RDF图的标准。
- <b>约束条件：</b>这些是确保数据完整性的规则。它们可以是<b>模型固有</b>（例如主键或类型安全）或<b>用户定义</b>（例如将值限制在特定范围内，如“百分比必须在 0 到 100 之间”）。
    
---

### 数据模型类型

讲座根据数据模型的结构和灵活性将其分为三种不同类型。

#### 结构化数据模型

这些模型依赖于一个严格的、预定义的模式（通常称为<b>写入时模式</b>，即必须在输入数据之前定义结构）。

- <b>关系模型：</b>
    - <b>基础：</b>它基于<b>集合（关系）</b>，这些集合（关系）被可视化为<b>表格</b>。
    - <b>组成部分：</b>表由<b>行（元组）</b>表示单个记录和<b>列（属性）</b>表示属性。
    - <b>链接：</b>实体之间的关系通过<b>共享属性值</b>（键）来表达。例如，<em>员工</em>表和<em>部门</em>表可能会被链接起来，因为它们都包含一个`部门ID`列。
    - <b>历史：</b>由埃德加·F·科德（Edgar F. Codd）于1970年提出，并在IBM System R等系统中得以实现。

- <b>面向对象模型：</b>
    - 这通过添加编程语言中的概念来扩展关系模型，例如<b>对象</b>、<b>属性</b>、<b>方法</b>、封装和继承。
        
#### 半结构化数据模型

这些模型允许<b>灵活组合</b>。它们不需要预先定义严格的模式（通常称为<b>可选模式</b>或<b>后定义模式</b>）。它们将结构化元素（标签/标记）与非结构化内容混合在一起。

- <b>RDF（资源描述框架）：</b>
    - <b>结构：</b>与 SQL 的表格结构不同，RDF 使用的是<b>图结构</b>，由<b>带标签的节点和边</b>组成。
    - <b>链接：</b>标签是<b>统一资源标识符</b>（URIs）。这使得RDF不仅能在一个数据库内链接数据，还能跨不同组织和领域链接数据，从而形成<b>数据网络</b>。
    - <b>灵活性：</b>可以轻松添加新关系，而不会“破坏”现有结构，使其非常适合集成来自异构源的数据。

- <b>XML:</b>
    - 使用<b>标签</b>来创建一个分层的<b>树结构</b>。
    - 它允许非结构化内容（文本）存在于标签之间。
        
#### 非结构化数据模型

这些模型处理的是内部结构对数据库系统本身不可见或无法解释的数据。

- <b>二进制大对象（BLOBs）：</b>示例包括图像（JPEG）、视频或PDF文件。
    - 数据库将文件视为单个数据“块”。其内部结构（例如，JPEG的像素如何压缩）仅由<b>处理它的应用程序</b>定义，而不是由数据库管理系统定义。

- <b>NoSQL /键值存储：</b>这些允许灵活的、任意组合的数据元素，通常优先考虑可扩展性而不是严格的结构。
    
### 概要比较

从<b>结构化</b>到<b>半结构化</b>的演变代表了连通性和灵活性的转变：

- <b>关系模型（结构化）</b>使用共享键连接<em>单个数据库</em>内的数据。
- <b>RDF（半结构化）</b>使用全局统一资源标识符（URI）连接<em>整个</em>网络中的数据。

## 判断给定的RDF文档是否符合四项关联数据原则，并解释原因

根据提供的讲座材料，特别是<b>学习目标2.2</b>，以下是关于如何判断RDF文档是否符合蒂姆·伯纳斯 - 李的四项关联数据原则的详细解释。

要评估一个RDF文档，你必须对照幻灯片中描述的四项原则来评估其内容。

### 原则：使用统一资源标识符（URI）作为事物的名称

<b>规则：</b>每个实体（人、地点、概念等）都应该有一个唯一的标识符。

<b>如何决定：</b>

- <b>检查：</b>文档是否为主体和谓词使用唯一标识符，而不仅仅是名称或字符串？
- <b>一致性：</b>如果文档能够区分<em>事物</em>和*事物的名称*，则该文档具有一致性。
    - <i>遵循示例：</i>使用`<http://dbpedia.org/resource/Aachen>`来指代这座城市。
    - <i>失败：</i>使用字符串“Aachen”作为三元组的主语。虽然“Aachen”是一个标签，但它不是一个能将该城市与大学或行政区区分开来的全局标识符。

- <b>原因：</b>这支持以资源为中心的数据建模视图，确保全局唯一性。
    
### 原则：使用HTTP URI，以便人们可以查找这些名称

<b>规则：</b>统一资源标识符（URI）应可通过网络进行解引用。它们必须将逻辑地址（名称）和物理地址（位置）结合起来。

<b>如何决定：</b>

- <b>检查：</b>查看文档中使用的 URI 的协议方案。
- <b>一致性：</b>如果标识符以`http://`或`https://`开头，则文档符合要求。
    - <i>遵循示例：</i> `<http://dbpedia.org/resource/Aachen>` 可以在浏览器中查找。
    - <i>失败：</i>使用像`urn:isbn:0451450523`这样的URN。虽然这是一个有效的URI（原则1），但浏览器无法直接“查找”或解引用它来检索数据。

- <b>原因：</b> HTTP URI 允许人类和机器使用标准的 Web 基础设施来检索有关资源的信息。
    
### 原则：使用标准（RDF、SPARQL）提供有用信息

<b>规则：</b>当查找 URI 时，服务器应使用 RDF、Turtle 或 JSON-LD 等标准格式返回数据。

<b>如何决定：</b>

- <b>检查：</b>文档本身是否采用标准化的RDF序列化格式编写？
- <b>一致性：</b>如果文档以W3C标准格式（如<b>Turtle</b>（`.ttl`）、<b>RDF/XML</b>或<b>JSON-LD</b>）进行序列化，则该文档符合一致性要求。
    - <i>遵循示例：</i>包含`@prefix dbr: <http://dbpedia.org/resource/>.`的文件，后面跟着有效的三元组。
    - <i>失败原因：</i>以专有二进制格式或缺乏语义定义的非标准 CSV 格式提供数据。

- <b>原因：</b>标准确保机器无需为每个新数据集定制软件就能解析和解释数据。
    
### 原则：包含指向其他 URIs 的链接

<b>规则：</b>将一个来源的事物与另一个来源的事物关联起来，就会创建一个数据“网格”。

<b>如何决定：</b>

- <b>检查：</b>文档是否仅引用其自身定义的资源（本地数据），还是会复用外部 URIs？
- <b>一致性：</b>如果文档将其主题与既定外部数据集（如DBpedia或schema.org）中的对象或谓词相关联，则该文档具有一致性。
    - <i>一致性示例：</i>一个关于亚琛的数据集，它链接到现有资源`<http://dbpedia.org/resource/Germany>`，而不是为德国创建一个新的、孤立的节点。
    - <i>失败：</i>一个文档，其中每个 URI 都属于`http://localhost/`或文档自身的命名空间，从而形成数据孤岛。

- <b>原因：</b>链接可实现<b>数据集成</b>和发现。它允许机器合并知识图谱（例如，将DBpedia中的人口数据与地方政府数据相结合），因为它们共享共同的“锚定”URI。
    
### 评估总结清单

要判断给定文档是否遵循这些原则，请提问：

1. <b>标识：</b>事物是否使用 URI 命名？（是/否）
2. <b>访问方式：</b>这些 URI 是`http://`还是`https://`？（是/否）
3. <b>标准化：</b>数据是否为有效的RDF格式（Turtle/JSON-LD）？（是/否）
4. <b>连通性：</b>是否包含指向外部数据集的链接？（是/否）
    
如果对所有四个问题的回答都是<b>是</b>，则该文档遵循关联数据原则。

## 资源描述框架

根据提供的讲座内容，以下是对<b> RDF（资源描述框架）</b>数据模型、其图形结构及其基本组件的详细解释。

### 核心概念：基于图的数据模型

RDF是<b>语义网</b>的标准数据模型。与关系数据库（使用表）或XML（使用树）不同，RDF使用<b>有向图</b>结构。

- <b>节点和弧：</b>信息以网络形式表示，其中<b>节点</b>表示实体（资源）或值，而<b>弧</b>（有向边）表示它们之间的关系。
- <b>相互关联：</b>此模型的优势在于<b>全球数据整合</b>。通过使用全球标识符（URI），RDF允许将来自不同来源（例如DBpedia和地方政府数据库）的数据自动合并。如果两个图对“Aachen”使用相同的URI，它们会立即连接起来，形成一个“数据网络”。
    
### RDF三元组：主语-谓语-宾语 

在RDF中，信息的基本单位是<b>三元组</b>。每一条知识都被分解为一个包含三个部分的简单陈述：

1. <b>主题：</b>被描述的“事物”（例如，亚琛市）。
2. <b>谓词：</b>特定的属性或关系（例如，`hasPopulation`或`isLocatedIn`）。
3. <b>对象：</b>属性的值或主体与之相关的另一个资源（例如，数字247,380或国家德国）。
    
<b>视觉呈现：</b>

在图表中，主语和宾语是节点（椭圆或矩形），谓语是从主语指向宾语的有向箭头。

### RDF术语：构建模块 

为了构建这些三元组，RDF使用三种特定类型的术语：<b>统一资源标识符（URI）</b>、<b>字面量</b>和<b>空白节点</b>。

#### 统一资源标识符（URI）/国际化资源标识符（IRI）

- <b>定义：</b>这些是用于在网络上唯一命名资源的全局标识符。
- <b>角色：</b>
    - 它们充当事物的“名称”。
    - 它们确保<b>全球唯一性</b>。`<http://dbpedia.org/resource/Aachen>`专门指的是这座城市，将其与任何其他名为“Aachen”的实体区分开来。
    - 它们允许<b>解引用</b>（查找），这意味着机器可以通过HTTP查找URI以检索更多数据。
    - <i>注意：</i>本讲义经常提及<b>IRI</b>（国际化资源标识符），它是允许使用 Unicode 字符（如变音符号）的 URI 的扩展，但概念保持不变。
        
#### 字面量 (L)

- <b>定义：</b>这些表示具体的数据值，如字符串、数字或日期。
- <b>角色：</b>它们为属性提供实际的“内容”或值。
- <b>XML 模式 (XSD)：</b>为确保机器理解这些值，RDF 使用<b>类型化字面量</b>。
    - 语法：`"值"^^<数据类型URI>`。
    - 数据类型通常采用自<b>XML 模式</b>（例如，`xsd:integer`用于整数，`xsd:date`用于日期）。
    - <i>示例：</i> `"247380"^^xsd:integer` 允许机器将人口视为一个数字（允许进行数学运算），而不仅仅是一串文本。

- <b>语言标签：</b>字符串文字也可以有语言标签（例如，`"Aachen"@de`与`"Aix-la-Chapelle"@fr`）。
    
#### 空白节点 (B)

- <b>定义：</b>也称为匿名节点，这些代表<b>没有全局 URI</b>的资源。
- <b>角色：</b>
    - <b>存在量化：</b>它们表达了“某物存在”且具有某些属性，而无需在全局范围内对其进行命名。
    - <b>局部作用域：</b>空白节点仅在其所在的特定文件或图中可识别。无法从外部网络引用它。

- <b>示例：</b>如果你想说“Aachen有一个地址”，且该地址由街道和邮政编码组成，你可能不会为该特定地址条目创建全局URI。相反，你可以使用空白节点将街道和邮政编码组合在一起，并关联到Aachen。
    
### RDF三元组的形式定义

该讲座基于每种术语类型的允许位置，提供了三元组的集合论定义。

已知：

- $U$ = URI (IRI) 集合
- $B$ = 空节点集
- $L$ = 文字集
    
一个RDF三元组$\langle s, p, o \rangle$定义如下：

$$(U \cup B) \times U \times (U \cup B \cup L)$$

此公式强制执行以下<b>规则</b>：

1. <b>主题（</b>$s$<b>）：</b>可以是<b> URI </b>或<b>空白节点</b>（$U \cup B$）。它<em>不能</em>是字面量。
2. <b>谓词 (</b>$p$<b>):</b>必须是一个<b> URI </b> ($U$).
    - 关系必须是全局定义的概念（如`schema:name`）。空白节点和字面量不能用作谓词。

3. <b>对象 (</b>$o$<b>):</b>可以是一个<b> URI </b>、一个<b>空白节点</b>或一个<b>字面量</b> ($U \cup B \cup L$)。
    
### 摘要

资源描述框架（RDF）数据模型创建了一个信息“网”。它从刚性的表格转向灵活的图，其中<b>统一资源标识符（URI）</b>作为连接数据的全局锚点，<b>文字（Literal）</b>保存原始值（通过<b>XML模式</b>进行类型化），以及<b>空白节点（Blank Node）</b>处理没有全局名称的本地复杂结构。

## 海龟

根据提供的讲座材料，以下是对<b> Turtle（简洁RDF三元组语言）</b>的详细解释。

### 定义与目的

<b>Turtle</b>是一种基于文本的RDF语法，旨在<b>简洁</b>且<b>易于人类阅读</b>。

- 它是冗长的<b>RDF/XML</b>格式与非常简单但重复的<b>N-Triples</b>格式之间的折衷方案。
- 它使RDF数据能够直观地编写，同时又不损失底层图模型的表达能力。
    
### 基本语法元素

一个Turtle文档由一系列的<b>三元组</b>组成。每个三元组包含一个<b>主语</b>、一个<b>谓语</b>和一个<b>宾语</b>，并且必须始终以<b>句点</b>（`.`）结尾。

- <b>IRI（国际化资源标识符）：</b>
    - 这些用于唯一标识资源。
    - 完整的国际资源标识符（IRI）用尖括号括起来：`<http://dbpedia.org/resource/Aachen>`。

- <b>字面量：</b>
    - <b>字符串：</b>用双引号括起来，例如`"亚琛"`。
    - <b>语言标签：</b>附加`@`符号，例如`"Aachen"@de`或`"Oche"@ksh`。
    - <b>数据类型：</b>使用`^^`显式定义，例如`"261472"^^xsd:integer`。
    - <b>自动解释：</b>海龟自动将某些不带引号的值识别为特定类型：
        - <b>整数：</b> `123` （解释为 `xsd:integer`）。
        - <b>小数：</b> `4.5` （解释为 `xsd:decimal`）。
        - <b>布尔值：</b> `true` 或 `false`（解释为 `xsd:boolean`）。
            
### 紧凑性缩写

海龟（Turtle）提供了多种机制来减少重复，使数据更加“简洁”。

#### 前缀和基数

- <b>@prefix:</b>允许您为长命名空间定义简短标签。例如，定义`@prefix dbr: <http://dbpedia.org/resource/>.`允许您编写`dbr:Aachen`而不是完整的IRI。
- <b>@base:</b>为文档定义一个默认的 URI。尖括号内的相对 IRI（例如，`<Aachen>`）会自动根据此基 URI 进行解析。
    
#### 分组三元组

- <b>分号 (</b><b>;</b><b>)：</b>当你想为<b>同一主题</b>声明多个属性时使用。
    - <i>结构：</i> `主语 谓语1 宾语1 ; 谓语2 宾语2 。`
    - 这样可以避免每行都重复主语。

- <b>逗号（</b><b>，</b><b>）：</b>当你想为<b>同一主语和同一谓语</b>列出多个对象时使用。
    - <i>结构：</i> `主语 谓语 宾语1 ，宾语2 。`。
        
#### “a”关键字

- Turtle提供了特殊关键字<b>a</b>作为属性<b>rdf:type</b>的简写。
- <i>示例：</i> `<亚琛> a dbo:City`等价于`<亚琛> rdf:type dbo:City`。
    
### 复杂结构

海龟允许在不显式命名每个节点的情况下表示复杂的数据结构。

#### 空白节点（匿名资源）

- <b>命名空白节点：</b>您可以使用以`_:`开头的标识符（例如`_:address1`）来定义一个没有全局IRI且仅存在于本地文件作用域内的节点。
- <b>方括号</b><b>[ ]</b><b>：</b>这是<b>匿名空白节点</b>的语法。它允许你“内联”定义一个资源及其属性。
    - <i>用法：</i>这对嵌套结构非常有效，例如嵌入在人员实体中的地址，而无需为地址创建 ID。
        
#### 集合（列表）

- <b>括号</b><b> ( ) </b><b>：</b>从技术上讲，RDF列表是由` rdf:first `和` rdf:rest `谓词链接的空白节点链。Turtle使用括号来抽象这种复杂性。
- <i>示例：</i> `( <A> <B> <C> )`表示一个有序列表。
- 解析器会自动将其转换为以`rdf:nil`结尾的底层RDF列表结构。
    
### 评论

在Turtle中，注释以井号（<b>#</b>）开头，一直延续到行尾。解析器会忽略这些注释。

## 将RDF图的图形表示转换为包含缩写的Turtle文档

根据提供的讲座内容，以下是对<b>学习目标2.5</b>的详细解释，该目标着重于将图形化的RDF模型转换为文本<b>Turtle</b>语法，利用特定的缩写和约定来确保数据紧凑且易读。

### 从图到文本：基本序列化

<b>Turtle（简洁RDF三元组语言）</b>是一种基于文本的语法，旨在成为RDF图的紧凑、人类可读的格式。

要将图形化的节点和边模型转换为Turtle，你需要将图形分解为<b>三元组</b>：

- <b>结构：</b> `<主语> <谓语> <宾语> 。`
- <b>句点：</b>句点`.`是必需的。它表示“语句”（三元组）的结束，就像句子末尾的句点一样。
    
### 标识符和缩写（CURIEs）

在可视化图中，节点通常用简短的名称标记，但在RDF中，它们必须是全局的<b>IRI</b>。Turtle使用<b>前缀</b>来使文本中的这些IRI保持简短。

- <b>CURIE（紧凑统一资源标识符）：</b> 你可以定义一个前缀并使用冒号分隔符，而不是编写像 `<http://dbpedia.org/resource/Berlin>` 这样的完整国际资源标识符（IRI）。格式为 `前缀:引用`。
- <b>前缀定义：</b>您必须在文档顶部声明前缀。
    - <i>语法：</i> `@prefix dbr: <http://dbpedia.org/resource/>.`
    - <i>用法：</i> `dbr:柏林`现在等同于完整的国际资源标识符（IRI）。

- <b>空前缀：</b>您可以定义一个没有标签（只有冒号）的前缀。
    - <i>语法：</i> `@prefix : <http://example.org/doc.ttl#>.`
    - <i>用法：</i> `:Berlin`解析为`http://example.org/doc.ttl#Berlin`。
        
### 相对 URI 和 @base 指令

在转换一个有许多资源共享相同根 URL 的图时，您可以使用<b>@base</b>指令为文档定义一个默认的 IRI。

- <b>解析：</b>尖括号内的相对IRI（例如，`<academics>`）会附加到已定义的基础URI上。
- <b>文件系统表示法：</b>正如您的查询中所提到的，这支持类似于文件系统的分层导航：
    - `@base <http://example.edu/research/>.`
    - `<./academics>`解析为`<http://example.edu/research/academics>`。
    - `<../academics>`向上移动一级，解析为`<http://example.edu/academics>`（从上下文中提到的标准 URI 解析规则推导得出）。
        
### 处理字面量（值）

在图中，代表值（字符串、数字）的矩形节点被转换为<b>文字</b>在Turtle中。

- <b>无类型字面量：</b>字符串用引号括起来：`"数据值"`。
- <b>语言标签：</b>要指定语言，请附加`@`和语言代码：`"Germany"@en`。
- <b>类型化字面量（XSD）：</b>要严格定义值类型（如整数或日期），可使用`^^`追加类型 URI。
    - <i>示例：</i> `"123"^^<http://www.w3.org/2001/XMLSchema#int>`。
    - <i>预定义类型：</i>正如您的文本中提到的，`rdf:HTML`和`rdf:XMLLiteral`是RDF自身定义的仅有的数据类型；其他的通常来自XML模式（XSD）。

- <b>语法糖（自动类型）：</b> Turtle自动识别某些不带引号的值：
    - `123`变成一个整数。
    - `4.5`变成了一个小数。
    - `true` 变成布尔值。
        
### 结构缩写（分组）

当图中的单个节点有多个出边时，你无需每次都重复主语。Turtle提供了标点符号来简化这种情况。

- <b>分号（</b><b>;</b><b>）：</b>当<b>主语</b>相同时使用，但<b>谓语</b>发生变化。
    - <i>逻辑：</i> `主语 谓语1 宾语1 ; 谓语2 宾语2 。`
    - <i>示例：</i> `:柏林 :首都 :DE ; :位于河岸 :施普雷河 。`。

- <b>逗号（</b><b>，</b><b>）：</b>当<b>主语</b>和<b>谓语</b>相同时使用，但<b>宾语</b>发生变化。
    - <i>逻辑：</i> `主语 谓语 宾语1 ，宾语2 。`
    - <i>示例：</i> `:DE :label "Germany"@en, "Deutschland"@de.`.

- <b>“a”关键字：</b>特定谓词`rdf:type`使用频率极高，因此Turtle用简单关键字`a`来替代它。
    - <i>示例：</i> `:柏林 a :城市`等同于`:柏林 rdf:类型 :城市`。
        
### 空白节点（匿名节点）

在图形模型中，你可能会看到没有标签的节点（通常用于对数据进行分组，如地址）。

- <b>命名空白节点：</b>如果该节点在多处被引用，则使用下划线为其赋予一个本地ID：`_:bn eg:knows eg:bob`。
- <b>嵌套空节点</b><b>[]</b><b>：</b>如果节点仅使用一次（例如，用于内联分组属性），则使用方括号。这在复杂嵌套中很常见。
    - <i>示例：</i> `[] eg:knows [ eg:name "Bob" ]`。这将创建一个结构，其中一个匿名资源知道另一个匿名资源，该资源的名称为 "Bob"。
        
### 转换逻辑总结

在读取图表以编写Turtle时：

1. 在顶部定义您的<b>前缀</b>。
2. 选择一个<b>主题</b>节点。
3. 撰写主题。
4. 编写一个<b>谓词</b>。
5. 写入<b>对象</b>。
    - 如果主题有更多属性，请使用<b>分号(;)</b>。
    - 如果谓词有多个值，请使用<b>逗号 (,)</b>。
    - 如果您已经完成了那个主题，请使用<b>句号 (.)</b>。

## 将包含缩写的Turtle文档转换为简单三元组形式的N-Triples，反之亦然

根据提供的课程材料，特别是<b>学习目标2.6</b>，以下是关于如何将Turtle文档（及其各种缩写）转换为简单、明确的<b>N-Triples</b>格式，以及反之亦然的详细说明。

从Turtle到N-Triples的转换涉及将缩写（如前缀和嵌套）“展开”为明确的、独立的三元组。

### 多元关系和空白节点

在RDF中，二元关系将一个主体与一个客体连接起来。然而，复杂的现实世界数据通常需要<b>多元关系</b>（两个以上事物之间的关系）或附加到关系上的属性（例如，仅对特定年份有效的人口统计数据）。

为了对其进行建模，我们使用<b>空白节点</b>来表示关系实例本身，多个属性会附加到该实例上。

#### 海龟（缩写形式）

Turtle允许您使用<b>方括号</b><b>[... ]</b>紧凑地表示这一点。这会内联创建一个“匿名”空白节点。

- <b>用户示例：</b>
    ```text
:Berlin :inhabitants [ :population 3433695 ; :year 1990 ] .
```
    在这里，`:柏林`通过`:居民`连接到一个匿名节点。该匿名节点有两个属性：`:人口`和`:年份`。
    
#### 转换为N-三元组（显式形式）

要将其转换为N-Triples，您必须：

1. <b>为空白节点分配一个显式的ID</b>（例如`_:b1`）。
2. <b>展开前缀：</b>将短前缀（如`:`）替换为完整的国际资源标识符（IRI）（例如，`<http://example.org/>`）。
3. <b>拆分为三元组：</b>为每个关系创建单独的一行。
    
- <b>N三元组结果：</b>
    ```text
<http://example.org/Berlin> <http://example.org/inhabitants> _:b1 .
_:b1 <http://example.org/population> "3433695"^^<http://www.w3.org/2001/XMLSchema#integer> .
_:b1 <http://example.org/year> "1990"^^<http://www.w3.org/2001/XMLSchema#integer> .
```
    <i>注意：</i>在N-Triples中，主语`:Berlin`不会重复；空白节点`_:b1`在第一行中作为宾语，在后续行中作为主语。
    
---

### RDF列表（集合）

您的查询提到了`rdf:Seq`、`rdf:Bag`和`rdf:Alt`。虽然这些都是有效的RDF容器类型，但特定的Turtle语法`(... )`表示一个<b>RDF集合</b>（一个链表），它在结构上有所不同，并使用`rdf:first`、`rdf:rest`和`rdf:nil`。

#### 海龟（缩写形式）

海龟使用括号来创建有序列表。

- <b>示例：</b>
    ```text
:Aachen :neighbors ( :Herzogenrath :Stolberg ) .
```
    
#### 转换为N-三元组（显式形式）

`(... )` 语法是 “语法糖”。在内部，解析器将其转换为一系列空白节点（链表）。

1. <b>头节点：</b>列表以一个空白节点开始（例如，`_:b1`）。
2. <b>rdf:first:</b>指向值（元素）。
3. <b>rdf:rest:</b>指向链中的下一个空白节点。
4. <b>rdf:nil:</b>标记列表的结束。
    
- <b>N三元组结果：</b>
    ```text
# The subject points to the head of the list
<http://example.org/Aachen> <http://example.org/neighbors> _:b1 .

# First element
_:b1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> <http://example.org/Herzogenrath> .
_:b1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> _:b2 .

# Second element
_:b2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> <http://example.org/Stolberg> .
_:b2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> .
```
    这表明`(... )`纯粹是这种显式、冗长结构的快捷方式。
    
---

### 其他转换（缩写与显式）

在不同格式之间转换时，您还必须处理标准缩写：

<table>
<colgroup>
<col width="200"/>
<col width="200"/>
<col width="200"/>
</colgroup>
<tbody>
<tr><td><p>功能</p></td><td><p>海龟（缩写）</p></td><td><p>N三元组（显式）</p></td></tr>
<tr><td><p><b>前缀</b></p></td><td><p><code>@prefix ex: &lt;http://example.org/&gt;.</code> 然后 <code>ex:City</code></p></td><td><p>必须编写完整的绝对IRI：<code>&lt;http://example.org/City&gt;</code>。</p></td></tr>
<tr><td><p><b>类型</b></p></td><td><p><code>a</code></p></td><td><p>必须写入完整的IRI：<code>&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt;</code>。</p></td></tr>
<tr><td><p><b>分组</b></p></td><td><p><code>;</code>（相同主语）和<code>，</code>（相同谓语）</p></td><td><p>必须在每一行重复主语和谓语。</p></td></tr>
<tr><td><p><b>字面量</b></p></td><td><p><code>123</code>（隐式整数）</p></td><td><p>必须明确：<code>&quot;123&quot;^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>。</p></td></tr>
</tbody>
</table>

<b>摘要：</b>

将Turtle转换为N-Triples<b>是一个</b>扩展<b>过程</b>：将前缀解析为完整的IRI，为匿名空白节点（`[]`）分配ID，将列表（`()`）展开为链接链，并确保每个事实都是独立的`主语谓语宾语`语句。将<b>N-Triples转换为Turtle</b>涉及<b>压缩</b>：查找公共前缀，使用`;`对公共主语进行分组，并使用`[]`和`()`等语法糖来隐藏复杂的空白节点结构。

 

## 从数据发布者（服务器）和数据使用者（用户代理）的角度解释关联数据原则

根据提供的讲座内容，以下是从<b>数据发布者（服务器）</b>和<b>数据使用者（用户代理）</b>两个角度对<b>关联数据原则</b>（学习目标2.7）的详细解释。

这些由蒂姆·伯纳斯-李提出的原则，将网络从“文档网络”扩展到了“数据网络”。

---

### 视角1：数据发布者（服务器）

服务器的作用是使用标准的网络协议使数据可用、可识别并相互关联。

<b>1. 使用 Coin URI 来命名事物</b>

- <b>操作：</b>发布者必须为他们想要描述的每个实体分配一个唯一的<b>统一资源标识符（URI）</b>——具体来说是国际化资源标识符（IRI）。
- <b>详情：</b>这不仅适用于文档，还适用于<em>任何</em>资源：人、物理地点（如亚琛市）、抽象概念或属性。
- <b>目标：</b>这确保了<b>全局唯一性</b>。与本地数据库ID（仅在一台计算机内唯一）不同，像`<http://dbpedia.org/resource/Aachen>`这样的URI充当全局“锚点”，确保不同系统使用这个名称时，它们指的是完全相同的实体。
    
<b>2. 使用HTTP URI，以便人们可以查找这些名称</b>

- <b>操作：</b>发布者应使用`http://`或`https://`方案来处理其URI，而不是使用`urn:`等抽象方案。
- <b>详情：</b>这将<b>逻辑地址</b>（事物的名称）与<b>物理地址</b>（查找其相关信息的位置）联系起来。
- <b>目标：</b>确保<b>可解引用性</b>。这使得人类和机器都能使用标准的网络基础设施（DNS、Web服务器）来访问资源。
    
<b>3. 收到请求后，以RDF和RDF模式返回有用信息</b>

- <b>操作：</b>当用户代理执行查找（解引用 URI）时，服务器必须使用标准格式返回数据。
- <b>详情：</b>语义网的标准格式是<b>RDF</b>（资源描述框架）。
    - 服务器以<b>三元组</b>（主语-谓语-宾语）图的形式提供数据。
    - 它使用<b>RDFS（RDF模式）</b>和本体来为数据提供“词汇表”或含义（例如，定义“城市”是一个类，“人口”是一个属性）。
    - 此数据可以采用以下格式进行序列化：<b>Turtle</b>、<b>JSON-LD</b>或<b>RDF/XML</b>。
        
<b>4. 在信息中包含指向其他统一资源标识符（URI）的链接</b>

- <b>行动：</b>发布者必须将其数据与他人持有的数据连接起来。
- <b>详情：</b>服务器不是将数据孤立存储，而是在其自身的三元组中使用外部统一资源标识符（URI）。例如，关于亚琛的本地数据集可能会链接到DBpedia中“德国”的资源（`<http://dbpedia.org/resource/Germany>`），而不是为该国创建一个新的本地节点。
- <b>目标：</b>这将创建<b>数据网络</b>（一个网状结构），从而实现数据发现。它允许用户无缝地从一个数据源浏览到另一个数据源。
    
---

### 视角2：数据消费者（用户代理）

用户代理（机器、机器人或浏览器）在这个网络中导航，以发现和处理信息。

<b>1. 将统一资源标识符（URI）视为事物的名称</b>

- <b>操作：</b>代理将统一资源标识符（URI）视为资源的全局唯一标识符。
- <b>详情：</b>代理理解 URI 指的是特定的 “话语对象”（以资源为中心的观点）。它能区分标识符和字面字符串；例如，它知道`<http://dbpedia.org/resource/Aachen>`是城市本身，与字符串标签 “Aachen” 不同。
    
<b>2. 查找HTTP URI</b>

- <b>操作：</b>代理使用HTTP协议对URI进行“解引用”。
- <b>详情：</b>由于发布者使用了标准的HTTP URI（原则2），代理可以发送标准请求（就像网络浏览器那样）来检索资源的描述。
    
<b>3. 查找包含有用信息的RDF/RDFS文档并处理SPARQL查询</b>

- <b>操作：</b>检索到文档后，代理解析<b>RDF</b>内容以理解图结构。
- <b>详情：</b>
    - <b>处理：</b>它解释由<b>语义</b>定义的<b>RDFS</b>（例如，理解类层次结构或数据类型，如`xsd:integer`）。
    - <b>查询：</b>它可以使用<b>SPARQL</b>（RDF的标准查询语言）对数据提出复杂的问题（例如，“选择所有人口超过20万的城市”）。
        
<b>4. 通过访问其他统一资源标识符（URI）发现更多内容</b>

- <b>操作：</b>代理遵循服务器提供的链接（原则4）来“爬取”知识图谱。
- <b>详情：</b>通过跟踪链接（例如，从 “亚琛” 点击到 “德国” 再到 “柏林”），代理可以在不同的服务器和组织之间发现相关数据。这使得代理能够将来自异构源的信息聚合到单个结果中。

读取并解释HTTP请求/响应配对，包括

HTTP重定向和内容协商

读取并解释HTTP请求/响应配对，包括

HTTP重定向和内容协商

## 读取并解析HTTP请求/响应配对，包括HTTP重定向和内容协商

## 解释哈希 URI 和斜杠 URI 背后的机制，这些机制用于将表示其他资源的 URI 与表示信息资源的 URI 区分开来

根据您查询中提供的内容和讲座材料，以下是对<b>哈希统一资源标识符（Hash URIs）</b>和<b>斜杠统一资源标识符（Slash URIs）</b>背后机制的详细解释。

这两种策略旨在解决语义网中的一个基本问题：区分<b>非信息资源</b>（现实世界中的对象或抽象概念，例如亚琛市）和<b>信息资源</b>（描述该对象的文档，例如RDF文件或HTML页面）。

### 哈希 URI

<b>机制：</b>

哈希 URI 使用<b>片段标识符</b>（由`#`符号表示）将文档的地址与其中的特定资源描述分开。

- <b>结构：</b> URI遵循` http://example.org/vocabulary#ConceptA `模式。如资料中所述，片段（以`#`开头）标识共享“基础IRI”内资源的特定部分或视图。
- <b>流程：</b>
    1. <b>去除哈希值：</b>当用户代理（客户端）查找哈希 URI 时，它会在本地处理该 URI。它<b>去除哈希值</b>和片段标识符（`#`之后的所有内容），以确定主资源的地址[用户查询]。
    2. <b>访问：</b>客户端向服务器请求基本 URI（`#`之前的部分）。
    3. <b>检索：</b>服务器返回整个文档（信息资源）。
    4. <b>提取：</b>文档下载后，客户端会在该文档中定位与片段标识对应的特定部分或实体（例如`#概念A`）。
        
<b>用例：</b>这通常用于词汇表（如RDFS或OWL）或小型数据集，在这些情况下，将所有相关术语下载到单个文件中是高效的。

### 斜杠 URI

<b>机制：</b>

斜杠 URI 使用标准的分层路径段（由`/`表示）来标识资源，例如`http://dbpedia.org/resource/Aachen`。由于服务器无法通过网络传输实体城市或抽象概念，因此它使用重定向机制。

- <b>结构：</b> URI的分层部分包含指向资源的路径。
- <b>流程（HTTP 303重定向）：</b>
    1. <b>请求：</b>客户端尝试访问 URI。
    2. <b>重定向：</b>由于 URI 表示的是一个“事物”（非信息资源）而非文档，服务器不会返回“200 OK”。相反，它会以<b>HTTP 303（参见其他）</b>状态码进行响应[用户查询]。
    3. <b>检索：</b>此状态码告知客户端：“您请求的对象不是文档，但您可以在另一个位置找到描述<em>它的</em>文档。” 然后客户端会自动跟随这个新的 URI 来检索信息。

- <b>内容协商：</b>

斜杠统一资源标识符（Slash URIs）支持<b>内容协商</b>，它允许根据用户需求提供不同版本的描述。
1. <b>规范：</b>在HTTP请求中，用户（客户端）使用`Accept`标头指定其首选内容格式（例如，人类用户使用 "我想要HTML"，机器使用 "我想要Turtle"）[用户查询]。
2. <b>重定向：</b>服务器分析此请求，并将客户端重定向到与请求格式匹配的特定文档（例如，重定向到`page.html`而不是`data.ttl`）[用户查询]。
    
### 概要比较

<table>
<colgroup>
<col width="200"/>
<col width="200"/>
<col width="200"/>
</colgroup>
<tbody>
<tr><td><p>功能</p></td><td><p>哈希 URI (<code>#</code>)</p></td><td><p>斜杠 URI (<code>/</code>)</p></td></tr>
<tr><td><p><b>标识</b></p></td><td><p>使用片段将“事物”与“文件”分开。</p></td><td><p>使用HTTP重定向将“事物”与“文件”分离。</p></td></tr>
<tr><td><p><b>服务器操作</b></p></td><td><p>立即返回文件（客户端处理逻辑）。</p></td><td><p>返回一个<b>303重定向</b>到特定文档URI [用户查询]。</p></td></tr>
<tr><td><p><b>效率</b></p></td><td><p>适用于小数据集（一次请求即可获取所有数据）。</p></td><td><p>适用于大型数据集（仅获取所需内容）。</p></td></tr>
<tr><td><p><b>灵活性</b></p></td><td><p>在数据格式方面灵活性较低。</p></td><td><p>支持<b>内容协商</b>（根据请求提供 HTML 或 RDF）[用户查询]。</p></td></tr>
</tbody>
</table>

## 描述资源与信息资源之间的联系（对应关系）

根据讲座内容和资料中所述的关联数据原则，以下是对<b>资源</b>与<b>信息资源</b>之间的联系，以及<b>对应关系</b>概念的详细解释（学习目标2.10）。

### 区别：资源与信息资源

要理解这种联系，首先必须区分语义网上存在的两种实体类型：

- <b>资源（“所指对象”）：</b>在RDF中，资源可以是*任何事物*。这包括实体事物（例如，亚琛市）、抽象概念（例如，“大学”的概念）或人。这些“现实世界”的对象无法通过互联网传输（你无法下载一座实体城市）。
- <b>信息资源（“文档”）：</b>这些是描述<em>资源的数字文档。示例包括RDF文件、</em> HTML页面或图像。这些<em>可以</em>通过互联网传输。
    
### 通信

<b>对应关系</b>是将这两者联系在一起的功能或机制。它将<b>资源的URI</b>（抽象名称）与<b>其对应信息资源的URI</b>（具体文件位置）关联起来。

这确保了用户在查找名称时（原则2：解引用），能够获得有用的数据（原则3：RDF/SPARQL）。

### 对应机制

对应函数的实现方式会因 URI 标识的是信息资源还是非信息资源（其他资源）而有所不同。

#### A. 信息资源（直接访问）

如果 URI 标识的是数字文档本身（例如，特定的 Turtle 文件），则对应关系是直接的。

- <b>协议：</b>当客户端对该 URI 执行 HTTP GET 请求时。
- <b>结果：</b>服务器以<b>200 OK</b>状态码响应，并立即发送文件内容。
- <b>用户文本上下文：</b>这符合 URI 直接表示一组信息的条件。
    
#### B. 其他资源（间接引用）

如果 URI 标识的是现实世界中的对象（非信息资源），服务器无法发送该对象。它必须使用一种机制来“指向”相应的信息资源。有两种标准策略可用于此：

1. <b>哈希 URI（片段标识符）</b>

- <b>结构：</b> URI包含一个哈希符号`#`（例如，`http://example.org/vocab#Concept`）。
- <b>机制：</b>通信由<b>客户端</b>处理。
    - 客户端剥离片段（`#概念`）并请求基础 URI。
    - 服务器返回基本文档（信息资源）的<b>200 OK</b>
    - 然后，客户端在该文档中搜索标记为`#概念`的特定实体。

- <b>对应关系：</b>资源 URI 是信息资源 URI 中的特定“视图”或片段。
    
1. <b>斜杠 URI（HTTP 303 重定向）</b>

- <b>结构：</b> URI 看起来像标准路径（例如，`http://dbpedia.org/resource/Aachen`）。
- <b>机制：</b>通信由<b>服务器</b>处理。
    - 客户端请求资源 URI。
    - 服务器知道这个 URI 代表的是一个“事物”，而不是一个文件。它会以<b>HTTP 303 See Other</b>（重定向）进行响应。
    - 此响应包含<em>对应信息资源</em>的位置（例如`http://dbpedia.org/data/Aachen.ttl`）。
    - 客户端向该新 URI 发起第二次请求，并收到一个<b>200 OK</b>响应。

- <b>对应关系：</b>服务器通过303头部将请求的资源URI显式映射到不同的信息资源URI。
    
### 对应函数概述

对应函数确保<b>名称</b>（IRI）是唯一的和全局的，通过HTTP协议正确处理对该名称信息的<b>访问</b>：

- <b>URI指向文档：</b> $\rightarrow$返回<b>200 OK</b>。
- <b>URI指向事物：</b> $\rightarrow$返回<b>303重定向</b>（斜杠）或返回<b>200 OK</b>包含文档（哈希）。

描述资源与信息之间的联系

资源（信函）

## 描述解引用图的过程，包括解析和对空白节点的正确处理

根据提供的资料，以下是对解引用图的过程、后续对该数据的解析以及对空白节点的具体处理的详细说明。

### 解引用过程

解引用是一种使用特定协议查找名称（URI）以检索其标识的资源相关信息的机制。

- <b>HTTP协议：</b>语义网依赖于<b>HTTP URI</b>（或IRI），以便人类和机器都能查找它们。当用户代理（如浏览器或脚本）访问HTTP IRI时，它会执行一次“查找”。
- <b>检索：</b>理想情况下，这种查找会返回标准化格式（如RDF）的有用数据。这使代理能够检索资源的描述。
- <b>零编辑（JSON-LD上下文）：</b>在某些情况下，例如使用JSON-LD时，服务器可以提供普通的JSON，但通过添加<b>HTTP链接头</b>使其可解释为链接数据图。此头指向远程上下文文件（例如`Link: <context.jsonld>; rel="..."`），允许客户端在不修改文件内容的情况下“解引用”JSON键的含义。
    
### 解析图

一旦数据被检索到（以Turtle或JSON-LD等格式序列化），就必须对其进行解析，以构建内部的<b>RDF图数据模型</b>。

- <b>激活：</b>激活一个专门的后端库来解析语法（例如，Turtle代码）。
- <b>前缀扩展：</b>在解析过程中，缩写会被解析。例如，在Turtle中，解析器在处理三元组之前，会将前缀名（如`rdfs:label`）替换为其完整的IRI（如`<http://www.w3.org/2000/01/rdf-schema#label>`）。
- <b>语法扩展：</b>解析器将“语法糖”（简写形式）转换为底层的图结构。
    - <b>集合：</b>在Turtle中写为`( <A> <B> )`的列表，解析器会在内部将其转换为通过`rdf:first`和`rdf:rest`谓词连接的空白节点链，以`rdf:nil`结尾。
    - <b>JSON-LD上下文：</b>JSON-LD处理器将JSON主体与`@context`结合，以生成抽象的RDF三元组。

- <b>图构建：</b>解析器的最终输出是一个内部图对象（例如，`rdflib.Graph`），由节点（资源/文字）和边（属性）组成。
    
### 处理空白节点

空白节点（匿名资源）在解析和存储过程中需要特殊处理，因为它们没有全局标识符。

#### A. 身份与范围

- <b>局部作用域：</b>空白节点的标识仅限于其所在的特定RDF图或文件。序列化中使用的标识符，如`_:b1`，仅在该特定文档中是唯一的。
- <b>非等价性：</b>在<em>不同</em>的RDF文档中，具有相同标签（例如`_:b1`）的两个空白节点<b>并非</b>同一资源。
    
#### B. 解析与序列化（斯科伦化）

- <b>存在量化：</b>从逻辑上讲，空白节点表示具有某些属性的“某物存在”。这对应于<b>斯科伦常量</b>在形式逻辑中。
- <b>标签变化：</b>在解析或序列化RDF时，空白节点的内部标识符可能会有所不同。源文件中标记为`_:b1`的节点可能会被解析器重命名，或者在图重新序列化时被重命名。
- <b>语法处理：</b>
    - <b>命名空白节点：</b>解析器将`_:标识符`解释为对文件中多次使用的特定空白节点的引用。
    - <b>匿名节点：</b>解析器将方括号`[... ]`解释为创建一个没有用户定义标签的“内联”新空白节点。
        
#### C. 内部存储（对象ID）

在<b>RDF模型</b>中的空白节点与其在数据库中的<b>内部对象ID</b>之间存在着关键区别：

<table>
<colgroup>
<col width="200"/>
<col width="200"/>
<col width="200"/>
</colgroup>
<tbody>
<tr><td><p>功能</p></td><td><p>空白节点（RDF模型）</p></td><td><p>内部对象ID（数据库）</p></td></tr>
<tr><td><p><b>可见性</b></p></td><td><p>在序列化中可见（例如，<code>_:b1</code>），但标签在全局范围内不稳定。</p></td><td><p>完全内部的，对用户不可见。</p></td></tr>
<tr><td><p><b>独特性</b></p></td><td><p>仅在特定的图/上下文中唯一。</p></td><td><p>在存储系统内全局唯一。</p></td></tr>
<tr><td><p><b>持久性</b></p></td><td><p>标签可能会随每次解析/序列化而改变。</p></td><td><p>通常在节点的生命周期内，跨事务保持稳定。</p></td></tr>
</tbody>
</table>

因此，在解析器处理解引用文件中找到的临时标签（`_:b1`）时，底层数据库系统会分配稳定的<b>内部对象标识符</b>（OIDs），以便高效地管理和持久引用这些节点。

## 描述构建用于本地处理的RDF数据集的过程

根据提供的讲座材料，特别是“RDF简介”、“Turtle”和“JSON-LD”部分的内容，以下是对构建用于本地处理的RDF数据集过程的详细解释（学习目标2.12）。

该过程涉及将非结构化信息（如自然语言）转换为结构化、机器可读的图格式。这涉及几个不同的阶段：

### 1. 概念建模：从语句到三元组

第一步是将信息分解为基本的<b>主谓宾</b>结构。

- <b>分解：</b>对自然语言句子（例如，“亚琛是一座城市”）进行分析，以确定被描述的实体（主语）、关系（谓语）以及值或相关实体（宾语）。
- <b>图结构：</b>这会创建一个心理或视觉上的图，其中节点表示资源或值，有向边表示关系。
    
### 2. 代币标识符（IRI）

为使数据在全球范围内具有唯一性和可合并性，必须将本地名称替换为<b>国际化资源</b><b>标识符（IRI）</b>。

- <b>全局唯一性：</b>不使用像“Aachen”这样有歧义的字符串，而是分配一个特定的IRI，例如`<http://dbpedia.org/resource/Aachen>`。
- <b>词汇选择：</b>你必须为谓词选择标准的国际资源标识符（IRI），以确保语义互操作性。例如，使用`rdf:type`对资源进行分类，或使用`schema:name`作为标签。
- <b>复用：</b>该过程鼓励复用现有的命名空间（例如，DBpedia、Schema.org），以促进数据集成，而不是为常见概念创建新的IRI。
    
### 3. 处理数据值（字面量）

对于表示具体数据而非其他资源的对象，你可以构造<b>字面量</b>。

- <b>类型：</b>您必须确定该值是简单字符串还是需要特定的数据类型。为了进行有效的本地处理（例如，正确排序数字），您需要附加<b> XML模式数据类型</b>（XSD）。
    - <i>示例：</i> `"247380"^^xsd:integer` 允许系统将人口视为数字而非文本字符串。

- <b>语言标签：</b>对于文本字符串，您可以附加语言标签（例如，`"Aachen"@de`）以支持多语言处理。
    
### 4. 处理匿名资源（空白节点）

如果某个资源存在但不需要全局引用（例如，特定的地址结构或列表容器），则构造一个<b>空白节点</b>。

- <b>存在量化：</b>它对“某物存在”这一概念进行建模，该物具有某些属性，但并不对其进行全局命名。
- <b>局部作用域：</b>在构建数据集时，你可以为这些节点分配临时的局部标识符（如`_:b1`），或使用嵌套的语法结构。需要注意的是，这些标识符仅在特定的局部文件或图中有效。
    
### 5. 序列化（写入数据）

要在本地处理抽象图，必须将其序列化为具体的文件格式。格式的选择会影响数据集在语法上的构建方式。

- <b>使用Turtle（为了可读性）：</b>
    - 您可以定义<b>前缀</b>（`@prefix`）来缩写长IRI。
    - 对于同一主语，你可以使用<b>分号</b>（`;`）来组合语句，对于同一谓语，则使用<b>逗号</b>（`,`）来创建一个紧凑的数据集。
    - 你可以使用语法糖，如`a`来表示`rdf:type`，或使用`( )`来表示列表。

- <b>使用JSON-LD（用于Web/API集成）：</b>
    - 您定义一个<b>@context</b>，将简单的JSON键（如 "name"）映射到完整的IRI（如`http://schema.org/name`）。
    - 你使用<b>@id</b>来确保JSON对象被视为图中的特定节点，而不仅仅是数据对象。
        
### 6. 解析与内部表示

构建用于处理的数据集的最后一步是将序列化数据加载到RDF环境中（例如，使用`rdflib`或`jupyter-rdfify`等Python库，如笔记本中所示）。

- <b>解析器激活：</b>系统读取语法（例如，Turtle或JSON-LD）并将其转换为内部对象模型。
- <b>斯科伦化/内部ID：</b>在此阶段，解析器将临时空白节点标签（如`_:b1`）转换为特定于本地数据库或内存存储的持久内部<b>对象ID</b>（OID）。这确保了即使外部标签不是全局稳定的，节点在处理过程中也能得到有效管理。
    
<b>总结：</b>构建RDF数据集的过程从<b>语言陈述</b> $\rightarrow$ <b>IRI分配</b> $\rightarrow$ <b>序列化</b>（Turtle/JSON-LD）$\rightarrow$ <b>解析</b>为内部图对象，以便进行查询和操作。

# 使用SPARQL查询RDF

## 基础

根据提供的讲座内容，以下是对<b>SPARQL基础</b>（学习目标3.1）的详细解释。

<b>SPARQL</b>（SPARQL协议和RDF查询语言）是W3C的标准<b>查询语言</b>，用于检索和操作存储在RDF图中的数据。它对RDF图的作用类似于SQL对关系数据库的作用。

### SPARQL查询的一般结构

标准的SPARQL查询包含按特定顺序处理的四个主要组件：

1. <b>前缀声明：</b>这些声明为长IRI定义缩写（CURIE），以提高可读性。与Turtle语法不同，SPARQL前缀声明<b>不</b>以`@`符号开头，也<b>不</b>以句号结尾。
    - <i>示例：</i> `PREFIX ex: <http://example.com/resources/>`

2. <b>查询表单和投影：</b>这指定了查询的类型（例如，`SELECT`）以及要返回的变量。
3. <b>数据集选择：</b> `FROM`或`FROM NAMED`子句指定正在查询的RDF图。
4. <b>WHERE子句（查询模式）：</b>包含与RDF数据匹配的<b>图模式</b>。
5. <b>查询修饰符：</b>诸如`ORDER BY`或`LIMIT`之类的子句，用于重新排列或截取最终结果。
    
---

### 可变投影

SPARQL中的变量充当占位符，绑定到数据中的RDF术语（URI、文字或空白节点）。

- <b>语法：</b>变量前缀可以是问号（<b>?</b>）或美元符号（<b>$</b>）。两者都是有效的，不过`?`更常用。
- <b>选择全部：</b>通配符<b>*</b>（例如，`SELECT *`）用于返回`WHERE`子句中绑定的所有变量。
    
---

### 查询表单

SPARQL支持四种特定的查询形式，每种形式返回不同类型的结果：

- <b>选择：</b>
    - <b>输出：</b>返回一个<b>表格</b>（解序列），其中每一行代表一个解，各列代表变量。
    - <i>用法：</i>这是最常见的形式，用于提取特定值。

- <b>询问：</b>
    - <b>输出：</b>返回一个<b>布尔</b>值（`真`或`假`）。
    - <i>用法：</i>检查<em>数据集中是否</em>存在特定的图模式，而不返回实际数据。它对于验证或是非问题很有用。

- <b>构建：</b>
    - <b>输出：</b>返回一个<b>新的RDF图</b>。
    - <i>用法：</i>它使用一个<b>图模板</b>。模板中的变量会用在`WHERE`子句中找到的解来填充，以生成新的三元组。这通常用于将数据从一种词汇表转换为另一种词汇表。

- <b>描述：</b>
    - <b>输出：</b>返回一个<b>RDF图</b>，用于描述一个或多个资源。
    - <i>用法：</i>描述的确切结构（例如，是否包含入边或出边）由SPARQL处理器实现决定，这使其在不了解确切数据结构的情况下对探索性分析很有用。
        
---

### 数据集选择（FROM子句）

数据集定义决定了查询的范围。

- <b>FROM </b><b>&lt;IRI&gt;</b><b>: </b>指定用作查询的<b>默认图</b>的图。如果使用多个`FROM`子句，则会合并它们的数据。
- <b>来自命名</b><b>&lt;IRI&gt;</b><b>：</b>用于包含可在查询模式中使用`GRAPH`关键字显式引用的图。
- 如果省略，则查询将针对端点预先配置的默认图执行。
    
---

### 查询模式（WHERE子句）

核心逻辑位于`WHERE`块中，该块包含一个<b>基本图模式（BGP）</b>。

- <b>三元组模式：</b>这些看起来像RDF三元组，但可能在主语、谓语或宾语位置包含变量。
- <b>隐式与：</b>一个三元组模式列表中的所有模式都必须匹配，解决方案才有效（逻辑合取）。
- <b>隐式连接：</b>如果相同的变量名（例如`?x`）出现在多个模式中，SPARQL引擎会确保该变量在所有出现的地方都绑定到<b>同一个RDF术语</b>，从而有效地连接数据。
- <b>缩写：</b> SPARQL支持在` WHERE `子句中使用Turtle风格的缩写：
    - <b>a</b>：`rdf:type`的简写。
    - <b>;</b>：重复下一个谓语-宾语对的主语。
    - <b>,</b>：重复下一个对象的主语和谓语。
        
---

### 序列修饰符

修饰符在模式匹配之后应用，以组织结果集。

- <b>ORDER BY:</b>根据变量值对结果进行排序。
    - <i>语法：</i> `ORDER BY?var`（默认升序），`ORDER BY ASC(?var)`，或`ORDER BY DESC(?var)`。

- <b>限制：</b>将输出限制为最大行数。在查询大型数据集（例如DBpedia）时，这对性能至关重要。
- <b>偏移量：</b>跳过前<em>x</em>个解。
    - <i>用法：</i>与`LIMIT`结合使用，可实现<b>分页</b>（例如，“显示结果11 - 20”）。

- <b>DISTINCT：</b>从结果集中删除重复行。
    - <i>用法：</i> `SELECT DISTINCT?x`确保即使`?x`通过多条路径匹配，它在表中也仅出现一次。

## 用不同形式（SELECT、CONSTRUCT、ASK、DESCRIBE）在SPARQL中编写BGP查询

根据提供的资料，以下是对基本图模式（BGP）、解决方案映射的理论概念，以及如何在四种主要的SPARQL查询形式（SELECT、CONSTRUCT、ASK、DESCRIBE）中使用它们的详细解释。

### 基本图模式（BGP）和解决方案映射

SPARQL查询的核心是<b>基本图模式（BGP）</b>，它位于`WHERE`子句中。

- <b>定义：</b>一个BGP是一组<b>三元组模式</b>。三元组模式类似于RDF三元组，但允许在主语、谓语或宾语位置使用变量（以`?`或`$`为前缀）。
- <b>逻辑合取：</b> BGP 表示逻辑 <b>与</b>。BGP 中的所有三元组模式都必须与数据匹配，解决方案才有效。
- <b>隐式连接：</b>如果同一变量名出现在BGP内的多个三元组模式中，SPARQL引擎会强制执行连接。该变量在其所有出现的地方都必须绑定到<b>相同的RDF术语</b>。
- <b>语法：</b> BGP可以使用Turtle风格的缩写，例如`;`（分号）来重复一个主语，`,`（逗号）来重复一个谓语，以及`a`来表示`rdf:type`。
    
#### 理论基础：解映射（$\mu$）和序列（$\Omega$）

为了评估BGP，SPARQL引擎执行模式匹配，以在数据中找到与该模式匹配的子图。

- <b>解决方案映射 (</b>$\mu$<b>)：</b>这是一个部分函数，它将变量 ($V$) 映射到 RDF 术语（URI、空白节点或文字）。它表示结果的单个“行”。
    - <i>用户示例：</i> $\mu_1(?borough) = :Pankow, \mu_1(?berlin) = :Berlin$这表明在数据中找到的一个特定匹配中，变量`?borough`对应实体`:Pankow`，`?berlin`对应`:Berlin`。

- <b>解决方案序列（</b>$\Omega$<b>）：</b>这是通过对数据集评估图模式生成的所有解决方案映射的集合（有序列表或多重集）。
    - <i>用户示例：</i> $\Omega = \{ \mu_1, \mu_2 \}$表示找到的完整答案集。
        
---

### SPARQL查询形式

虽然BGP（`WHERE`子句）决定了<em>匹配</em>哪些数据，但<b>查询表单</b>决定了<em>如何</em>返回这些数据。

#### A. 选择

<b>SELECT</b>查询返回一个变量绑定的表（解序列）。它从模式匹配阶段找到的解映射中投影特定变量。

- <b>功能：</b>它是形式为$SELECT_S(P)$的代数表达式，其中$P$是图模式，$S$是要投影的变量集。
- <b>输出：</b>一个表格，其中行代表解，列代表变量。
- <b>代数处理过程：</b>它对图模式进行求值以得到$\Omega$，然后投影出所选变量。
- <b>示例：</b>
    ```text
SELECT ?y WHERE {
   _:x :name ?y .
}
```
    如果图包含`_:x :name "柏林"`，则结果是包含映射`{?y -> "柏林"}`的序列。
    
#### B. 询问

<b>ASK</b>查询返回一个<b>布尔值</b>（True/False）。它检查是否存在解决方案，而不返回实际数据。

- <b>函数：</b>它是形式为$ASK(P)$的表达式。
- <b>逻辑：</b>如果解映射集`不为空`（$\Omega \neq \emptyset$），则返回$\Omega$ <b>TRUE</b>，否则返回`FALSE`。
- <b>用例：</b>用于验证数据集中是否存在特定模式或条件（例如，“是否有第六学期的学生？”）。
- <b>示例：</b>
    ```text
ASK WHERE {
   ?student :semesterCount ?s .
   FILTER(?s > 10)
}
```
    
#### C. 构建

<b>CONSTRUCT</b>查询返回一个<b>新的RDF图</b>。它使用图模板根据查询结果生成三元组。

- <b>功能：</b>它接受一个图模式（$P$）来查找解决方案，以及一个三元组模式的模板集（$Q$）来生成新数据：$CONSTRUCT(P, Q)$。
- <b>流程：</b>
    1. 计算`WHERE`子句（$P$）以获得解序列$\Omega$。
    2. 对于$\mu$中的每个映射$\Omega$，将变量值应用于模板（$Q$）。
    3. 所有这些生成的三元组的并集构成了最终的图。

- <b>处理空白节点：</b>如果模板（$Q$）包含空白节点，系统会为每个解决方案映射生成一个<b>新的空白节点</b>。这确保为每个结果创建不同的资源。
- <b>示例：</b>
    ```text
CONSTRUCT { ?student ex:name ?name }
WHERE { ?student :name ?name }
```
    这将使用`ex:name`属性将数据转换为新图。
    
#### D. 描述

该<b>DESCRIBE</b>查询返回描述特定资源的<b>RDF图</b>。

- <b>功能：</b>它返回由查询中提供的IRI或变量标识的资源的RDF描述。
- <b>灵活性：</b>“描述”的确切定义<b>取决于具体实现</b>。SPARQL标准并未严格定义它。通常，它返回资源作为主语的所有三元组，有时也返回资源作为宾语的三元组（逆关系）或相关的空白节点。
- <b>用例：</b>当您不知道围绕资源的数据的确切结构时，对探索性数据分析很有用。
- <b>示例：</b>
    ```text
DESCRIBE :student28106
```
    这将返回有关该特定学生的所有可用信息（三元组）。

## 在查询中正确应用 UNION

根据提供的资料，以下是对<b>学习目标3.3：在查询中正确应用UNION</b>的详细解释。

### 1. UNION的概念

SPARQL中的`UNION`子句用于合并来自两个或更多可选图形模式的结果。它允许您搜索<b>符合</b>一个模式<b>或</b>另一个模式的数据，实际上起到了逻辑<b>OR</b>的作用。

- <b>机制：</b> SPARQL处理器独立评估由` UNION `分隔的每个图形模式<b>。</b>这些独立评估的结果（解决方案映射）随后合并为一个结果集。
- <b>代数定义：</b>形式上，联合运算符接受两组解映射（$\Omega_l$ 和 $\Omega_r$），并创建一个新集合，其中包含在任一集合中找到的所有映射：$Union(\Omega_l, \Omega_r) := \{ \mu \mid \mu \in \Omega_l \text{ 或 } \mu \in \Omega_r \}$。
    
### 2. 分析你的示例

您的查询提供了两种方式来编写城市名称的请求，其中名称属性可能会有所不同（即`:name`或`rdfs:label`）。

#### 方法A：重复常见模式（冗长）

```text
SELECT ?name WHERE {
  { ?city :name ?name . ?city a :City }
  UNION
  { ?city rdfs:label ?name . ?city a :City }
}
```

- <b>逻辑：</b>这里，条件`?city a :City`在`UNION`的每个分支中重复出现。
- <b>执行过程：</b>处理器先搜索具有`:name`的城市，然后独立搜索具有`rdfs:label`的城市。最后，将两个列表合并。
- <b>冗余性：</b>虽然这种方法有效，但它会迫使你在每个替代块中重复共享约束（如作为`:City`）。
    
#### 方法B：提取公因式（优化版）

```text
SELECT ?name WHERE {
  ?city a :City .
  { ?city :name ?name }
  UNION
  { ?city rdfs:label ?name }
}
```

- <b>逻辑：</b>你在`UNION`块外部声明一次公共要求（`?city a :City`）。
- <b>执行：</b>此操作充当逻辑合取（AND）。查询引擎查找类型为`:City` <b>且</b>（具有`:name` <b>或</b>具有`rdfs:label`）的资源。
- <b>优点：</b>通常，这样做有利于提高可读性和可维护性。正如您在查询中提到的，“如果某个查询被重复使用，可以将其放在`UNION`块外部，然后应用于联合的组合结果”，从而实现“一次使用”。
    
### 3. 应用 UNION 的关键规则

<b>1. 独立评估</b>

独立计算`UNION`块内的模式。在该特定块的初始模式匹配期间，第一个块中绑定的变量不会约束第二个块。但是，如果变量（例如示例中的`？ city`）绑定在`UNION`之外，则该绑定将携带到联合计算中。

<b>2. 变量绑定</b>

- <b>共享变量：</b>如果同一变量（例如`?name`）在两个分支中都被使用，那么无论哪个分支产生了解决方案，它都会在最终结果中被绑定。
- <b>未共享变量：</b>如果一个变量仅出现在一个分支中（例如，`?name`在分支1中，`?label`在分支2中），则对于由另一个分支生成的解，它将保持<b>未绑定</b>状态。
    
<b>3. 处理重复项（集合语义与包语义）</b>

- <b>标准行为：</b>与数学集合的并集不同，SPARQL的`UNION`子句默认保留重复项（类似于SQL的`UNION ALL`）。如果一个城市<em>同时</em>有`:name` “柏林”和`rdfs:label` “柏林”，且两者都与查询匹配，那么“柏林”将在结果中出现两次。
- <b>修正：</b>为确保结果唯一，您必须显式使用`SELECT DISTINCT`修饰符。
    
### 4. 应用示例

从讲座数据来看，假设我们要列出所有人员，无论他们是学生还是教授。我们可以使用`UNION`来合并这两种不相交的类型：

```text
SELECT ?person ?name WHERE {
  {
    ?person a :Student ;       # First block: find students
            :name ?name .
  }
  UNION
  {
    ?person a :Professor ;     # Second block: find professors
            :name ?name .
  }
}
```

此操作将学生集合与教授集合合并为一个“人员”列表。

## 在查询中正确应用OPTIONAL

根据提供的讲座内容，以下是对<b>学习目标3.4：在查询中正确应用OPTIONAL</b>的详细解释，具体分析你的示例查询。

### 1. OPTIONAL的目的

在现实世界的RDF数据集中，数据往往是“参差不齐”或异构的，这意味着并非所有资源都共享同一组属性。例如，虽然每个城市可能都有名称，但数据集中并非每个城市都有记录的邮政编码。

- <b>标准行为（BGP）：</b>标准的基本图模式充当逻辑<b>与</b>。如果您在查询中未使用`OPTIONAL`（例如，`?city :name?name.?city :zip?zip.`），SPARQL处理器将丢弃任何<em>既</em>没有名称又没有邮政编码的城市。
- <b>可选行为：</b> `可选`子句可防止这种数据丢失。即使`可选`块内的模式匹配失败，它也允许查询返回在主模式中找到的信息。
    
### 2. 分析您的查询

您的特定查询旨在检索城市名称列表，若有可用信息，还会检索其邮政编码。

```text
SELECT ?name ?zip WHERE {
   ?city :name ?name .        # Mandatory Pattern
   OPTIONAL {
      ?city :zip ?zip         # Optional Pattern
   }
}
```

#### 评估机制

1. <b>强制匹配：</b>处理器首先计算`OPTIONAL`块外的模式（`?city :name?name`）。它会找到所有具有`:name`的资源，并绑定变量`?city`和`?name`。如果某个资源没有名称，则会被完全排除。
2. <b>可选匹配：</b>对于步骤1中找到的每个解决方案，处理器都会尝试匹配`OPTIONAL`子句（`?city :zip?zip`）大括号内的模式。
3. <b>结果生成：</b>
    - <b>情况A（找到匹配项）：</b>如果城市有邮政编码，则变量`?zip`被<b>绑定</b>到该值。结果行将同时包含名称和邮政编码。
    - <b>情况B（未找到匹配项）：</b>如果城市<em>没有</em>邮政编码，则解决方案<b>保持不变</b>。但是，对于该特定行，变量`?zip`仍然<b>未绑定</b>（为空或空值）。
        
### 3. 代数定义（左连接）

从正式的理论角度来看（来源6），`OPTIONAL`子句对应于关系代数中的<b>LeftJoin</b>运算符。

- 对于`P1 OPTIONAL P2`的代数表达式定义为`LeftJoin(eval(P1), eval(P2))`。
- 左连接`被定义为两个集合的并集：`
    1. <b>连接</b> $P1$和$P2$（其中数据在两者中都存在）。
    2. 减去<b> </b>的$P1$和$P2$（来自$P1$的行与$P2$不兼容，保持$P1$变量绑定，$P2$变量未绑定）。
        
### 4. 高级应用：检查缺失数据

您可以将`OPTIONAL`与`FILTER`和`BOUND()`函数结合使用，以专门查找数据<em>缺失</em>的项目（失败即否定）。

例如，要查找有名称但<b>没有</b>邮政编码的城市，您可以检查`?zip`变量是否未被绑定：

```text
SELECT ?name WHERE {
   ?city :name ?name .
   OPTIONAL { ?city :zip ?zip }
   FILTER (!BOUND(?zip))
}
```

此模式仅保留可选匹配失败的解决方案。

## 结合使用BIND... AS和FILTER与涉及函数（过滤器、函数和修饰符）的表达式

根据提供的讲义材料，以下是关于结合函数使用<b>BIND</b>和<b>FILTER</b>的详细解释，对应学习目标3.5。

### 1. 使用FILTER限制结果

<b>FILTER</b>子句用于限制图模式生成的解。它会对每个潜在解计算一个布尔条件；如果条件计算结果为`true`，则保留该解；如果为`false`或发生错误，则丢弃该解。

#### A. 比较和算术运算符

过滤器对图模式进行操作，并使用标准运算符限制值。

- <b>数值比较：</b>你可以使用诸如`=`、`!=`、`<`、`>`、`<=`和`>=`等运算符来比较数值类型（整数、小数、浮点数）。
    - <i>示例：</i> `FILTER (?population > 350000)`确保仅返回人口超过350000的实体。

- <b>字符串比较：</b>这些运算符也适用于基于字典序的字符串。默认情况下，字符串比较区分大小写。
- <b>数据类型：</b>比较逻辑遵循 XML 模式数据类型 (XSD)。例如，`xsd:integer`、`xsd:dateTime`和`xsd:boolean`。
    
#### B. 逻辑连接词

您可以使用逻辑运算符将多个条件组合成一个复杂的表达式：

- <b>AND (</b><b>&&</b><b>): </b>两个条件都必须为真。
- <b>或(</b><b>||</b><b>)：</b>至少有一个条件必须为真。
- <b>NOT (</b><b>!</b><b>):</b>反转布尔结果。
    
<i>用户示例上下文：</i>

查询`FILTER (str(?n)="Aachen" &&?p>500000)`将字符串相等性检查与数值比较结合起来。结果要显示，两者都必须满足。

#### C. 过滤器中的函数

SPARQL允许在`FILTER`子句中使用函数来执行复杂的检查：

- <b>字符串函数：</b>
    - `REGEX(?var, "pattern", "flags")`: 检查字符串是否与正则表达式匹配（例如，使用标志 "i" 表示不区分大小写）。
    - `STRSTARTS` / `STRENDS`：检查字符串是否以特定序列开头或结尾。
    - `包含`：检查字符串是否包含子字符串。
    - `LCASE` / `UCASE`：将字符串转换为小写或大写，以便进行不区分大小写的比较。

- <b>语言函数：</b> `LANGMATCHES(LANG(?v), "en")`检查一个文字是否标记了特定语言。
- <b>数据类型函数：</b> `DATATYPE(?v)`检索文字的类型IRI。
    
---

### 2. 处理否定：OPTIONAL和!BOUND

检查某事物<em>不存在</em>（失败即否定）的最常见模式之一是将`OPTIONAL`与`FILTER`以及`BOUND()`函数结合使用。

- <b>BOUND(?x)</b>：如果变量`?x`在当前解中已绑定到某个值，则返回`true`，否则返回`false`。
- <b>模式：</b>
    1. 匹配主要模式（例如，查找城市）。
    2. 使用`OPTIONAL`来尝试匹配额外的数据（例如，查找城市所在的州）。
    3. 使用`FILTER (!BOUND(?state))`仅保留可选匹配<b>失败</b>的解。
        
<i>用户示例上下文：</i>

```text
SELECT ?city WHERE {
  ?city :name ?name .
  OPTIONAL { ?city :state ?state }
  FILTER (!bound(?state))
}
```

此查询返回<b>没有</b>记录状态属性的城市。如果可选块找到一个状态，`?state`将被绑定，`!bound(?state)`将变为假，并且该城市将被过滤掉。

---

### 3. 使用BIND... AS赋值

虽然`FILTER`用于移除解，<b>BIND</b>则用于计算新值或修改现有值，并将其赋给变量。

- <b>语法：</b> `BIND (表达式 AS?新变量)`。
- <b>作用域：</b>新变量在后续的图形模式、过滤器和`SELECT`子句中可用。
    
#### A. 算术运算

您可以对数值变量执行数学运算（`+`、`-`、`*`、`/`）。

- <i>源示例：</i> `BIND ((6 -?currentSemester) AS?remainingSemesters)`计算标准时长与当前学期数之间的差值。
- <i>用户示例：</i> `BIND ( abs(?pPop -?nPop) AS?diffPop )`计算两个人口变量之间的绝对差值。
    
#### B. 字符串和逻辑操作

`BIND`也用于字符串连接或条件逻辑。

- <b>连接操作：</b> `BIND (CONCAT("Prof. ",?name) AS?formalName)`用于组合字符串。
- <b>条件赋值：</b> `BIND (IF(条件, 值为真时的结果, 值为假时的结果) AS?变量)`允许进行条件值赋值。
    
---

### 4. 理论背景：价值空间

从查询评估的角度来看，重要的是要注意`FILTER`操作通常作用于<b>字面量的值空间</b>，而不是词法字符串。

- 例如，`"01"^^xsd:integer`和`"1"^^xsd:integer`是不同的字符串，但在值空间中，它们是相同的。过滤器`FILTER (?x = 1)`对两者的计算结果都为`true`。

## 此外

根据提供的讲座材料，以下是对SPARQL中附加过滤函数和聚合度量的详细解释（学习目标3.6）。

### 1. 高级筛选函数

除了基本的比较运算符外，SPARQL还提供了特定的函数，用于根据字面量的字符串内容、语言标签或数据类型来检查和过滤字面量。

#### 字符串操作与匹配

字符串过滤器用于确定文本字面量是否与特定模式匹配。

- <b>REGEX(?variable, "pattern", "flags")</b>：此函数使用正则表达式来匹配字符串值。它允许进行复杂的模式匹配。您可以添加标志，例如`"i"`，以使搜索<b>不区分大小写</b>。
    - <i>示例：</i> `FILTER (REGEX(?name, "^S", "i"))`匹配以"S"或"s"开头的名称。

- <b>CONTAINS(字符串, 子字符串)</b>：检查字符串是否包含特定的子字符串。这通常与`LCASE()`（小写转换）一起使用，以确保不区分大小写的匹配，因为`CONTAINS`默认情况下区分大小写。
    - <i>用户查询上下文：</i> `FILTER (CONTAINS(?name, "erlin"))`将匹配 "Berlin" 或 "Merlin"。

- <b>STR(?variable)</b>：将资源（IRI或文字）转换为其简单字符串形式。
    - <i>修正：</i>你的示例`FILTER (STR(?n ="Aachen")`表明是在检查字符串值是否等于 "Aachen"。正确的语法通常会将提取和比较分开：`FILTER (STR(?n) = "Aachen")`。

- <b>STRSTARTS</b><b> / </b><b>STRENDS</b>：这些函数用于检查字符串是否以特定序列开头或结尾。
    
#### 语言标签

RDF文字可能包含语言标签（例如，`"München"@de`）。SPARQL提供了基于这些标签进行过滤的函数。

- <b>LANG(?variable)</b>: 提取文字的语言标签（例如，返回 "en" 或 "de"）。
- <b>LANGMATCHES(tag, range)</b>：检查语言标签是否与特定语言范围匹配。
    - <i>用户查询上下文：</i>要检查英文标签，模式为：`FILTER (LANGMATCHES(LANG(?name), "en"))`。
        
#### 数据类型

您可以确保变量与特定的 XML 模式数据类型 (XSD) 匹配。

- <b>DATATYPE(?variable)</b>: 返回文字数据类型的 IRI。
    - <i>用户查询上下文：</i> `FILTER (DATATYPE(?shoeSize) = xsd:integer)`确保变量`?shoeSize`被严格视为整数，这一点很重要，因为现实世界的数据可能是异构的。
        
---

### 2. SELECT子句中的聚合

SPARQL允许您直接在`SELECT`行中计算汇总值（聚合）。这与使用`BIND`不同，后者是为单个解决方案计算值。

#### 常用聚合函数

这些函数从一组（或一群）解中计算出单个值。

- <b>COUNT(?var)</b>: 统计变量被绑定的次数。你可以使用`COUNT(DISTINCT?var)`仅统计唯一值，或使用`COUNT(*)`统计总解决方案行数。
- <b>AVG(?var)</b>：计算数值的算术平均值。
- <b>MIN(?var)</b><b> / </b><b>MAX(?var)</b>: 查找最小或最大的值（数值或字典序）。
- <b>SUM(?var)</b>: 对数值进行求和。
    
#### 分组结果（`按组`）

当你在`SELECT`行中将特定变量（如`?state`）与聚合函数（如`MIN(?population)`）混合使用时，你<b>必须</b>对结果进行分组。

- <b>按?variable分组</b>：此操作按指定变量对解决方案集进行分组。然后<em>按组</em>计算聚合，而不是对整个数据集进行计算。
- <b>示例逻辑：</b>
    - 要获取<em>所有</em>城市的平均人口：
    `SELECT (AVG(?population) AS?avgPop) WHERE...`.
    - 要获取每个州的最小人口数<em>（如您的查询所示）</em>：
        ```text
SELECT ?state (MIN(?population) AS ?minPop)
WHERE { ... }
GROUP BY ?state
```
        这确保了`MIN`函数会为找到的每个唯一`?state`分别计算最小人口数。
        
#### 过滤组（`HAVING`）

如果您想在<em>聚合</em>后过滤结果（例如，“仅显示拥有超过 5 个城市的州”），则不能使用`FILTER`。您必须使用<b>HAVING</b>子句。

- <i>示例：</i> `HAVING (COUNT(?city) > 5)`。

# SPARQL查询评估

## 基于形式定义解释基本图模式匹配

根据提供的讲座材料，以下是基于形式定义对基本图模式匹配的详细解释。

正如您所指出的，SPARQL解决方案的计算遵循一个三步过程：将查询转换为代数表达式、计算图模式和计算查询形式。<b>基本图模式（BGP）匹配</b>是在第二步（计算图模式的代数表达式）中使用的基本机制。

### 1. 模式匹配的形式组件

要理解形式化定义，我们必须首先定义用于将抽象查询模式转换为具体数据的映射。

- <b>三元组模式：</b>一个元组$(s, p, o)$，其中每个元素可以是 URI、空白节点、文字或<b>变量</b>。基本图模式（BGP）是这些三元组模式的集合。
- <b>解映射（</b>$\mu$<b>）：</b>这是一个部分函数，它将查询中的<b>变量</b>映射到RDF术语（URI、空白节点或字面量）。解序列$\Omega$是这些解映射的有序列表。
- <b>RDF实例映射（</b>$\sigma$<b>）：</b>这是从查询模式中的<b>空白节点</b>到数据集中RDF术语的映射。这处理了空白节点的存在量化（即“存在某物”）。
    
### 2. 匹配的形式定义

形式上，如果关于变量和空白节点的特定条件得到满足，则解映射$\mu$被认为是RDF图$P$上基本图模式$G$的解。

定义指出，如果满足以下条件，则$\mu$是一个解：

1. <b>定义域定义：</b> $\mu$ 精确地定义在 $P$ 中出现的变量名上。
2. <b>空白节点映射：</b>存在一个映射$\sigma$从$P$中的空白节点到RDF术语。
3. <b>子图条件：</b>通过将这些映射应用于模式而得到的三元组集合是活动图$G$的<b>子图</b>。
    
在数学上，这表示为：

$$\mu(\sigma(P)) \subseteq G$$

这里，$\mu(\sigma(P))$表示首先根据$\sigma$替换$P$中的空白节点，然后根据$\mu$替换变量后得到的图。

### 3. 评估函数 (`eval`)

在SPARQL代数的上下文中，评估函数`eval(D(G), tp)`计算三元组模式`tp`相对于图`D(G)`的结果。它严格由上述模式匹配标准定义：

$$eval(D(G), tp) := \{ \mu \mid dom(\mu) = vars(tp) \text{ and } dom(\sigma) = bn(tp) \text{ and } \mu(\sigma(tp)) \in D(G) \}$$

这意味着评估返回所有解决方案映射的集合$\mu$，其中变量和空白节点的有效映射会产生一个实际存在于数据集中的三元组。

### 4. 示例

为了直观呈现这一正式过程，我们来看讲座中给出的以下示例：

- <b>RDF图 (</b>$G$<b>): </b>包含三元组`:Neukoelln :name "Neukoelln"@en`. 
- <b>三元模式 (</b>$tp1$<b>):</b> `_:x :name?y`.
    - 此模式包含一个空白节点（`_:x`）和一个变量（`?y`）。
        
为了确定是否存在匹配，我们寻找映射$\sigma$和 $\mu$：

1. <b>应用</b>$\sigma$<b>：</b>我们将空白节点`_:x`映射到` URI :Neukoelln`。
    - $\sigma(\text{tp1}) = \text{:Neukoelln :name ?y}$ .

2. <b>应用</b>$\mu$<b>:</b>我们将变量`?y`映射到字面量`"Neukoelln"@en`。
    - $\mu(\sigma(\text{tp1})) = \text{:Neukoelln :name "Neukoelln"@en}$ .

3. <b>检查子图：</b>是否存在`:Neukoelln :name "Neukoelln"@en`在$G$中？是。
    
因此，模式匹配，并且$\mu = \{?y \rightarrow \text{"Neukoelln"@en}\}$是一个有效的解决方案。

## 给定一个SPARQL查询，生成该查询的SPARQL代数表达式

根据提供的讲座材料（来源“SemanticWebLecture5-SPARQL Query Evaluation.pdf”），以下是关于如何从查询生成SPARQL代数表达式的详细解释。

这个过程涉及两个不同的步骤：翻译<b>图模式</b>（`WHERE`子句中的逻辑）和翻译<b>查询形式</b>（例如`SELECT`、`CONSTRUCT`）。

### 1. 理解构建模块（$V$、$U$、$B$、$L$）

在构建代数之前，有必要定义表达式中使用的术语。你特别询问了$V$：

- $V$$\mathcal{V}$这表示<b>变量</b>的无限集合（例如，`?x`、`?y`、`?city`）。变量是占位符，与特定的RDF数据不相交。
- $U$<b>：</b>一组<b> URI</b>（全球唯一标识符）。
- $B$<b>：</b>一组<b>空白节点</b>（本地标识符）。
- $L$<b>:</b>一组<b>文字</b>（如字符串或整数等数据值）。
    
因此，当符号提到 $g \in (U \cup V)$ 时，它表示图$g$可以通过特定的 URI（命名图）或在查询执行期间绑定的变量来标识。

### 2. 图模式的代数表达式（`WHERE`子句）

SPARQL查询的核心逻辑在于基本图模式（BGP）。代数是使用特定运算符递归构建的。如果我们将$P_1$和$P_2$作为图模式，翻译规则如下：

<table>
<colgroup>
<col width="200"/>
<col width="200"/>
<col width="200"/>
</colgroup>
<tbody>
<tr><td><p>SPARQL语法</p></td><td><p>代数运算</p></td><td><p>描述</p></td></tr>
<tr><td><p><code>tp1. tp2</code></p></td><td><p>$$P_1 \text{ JOIN } P_2$$</p></td><td><p>两个模式都必须匹配（逻辑与）。</p></td></tr>
<tr><td><p><code>P1 UNION P2</code></p></td><td><p>$$P_1 \text{ UNION } P_2$$</p></td><td><p>任一模式均可匹配（析取）。</p></td></tr>
<tr><td><p><code>P1可选P2</code></p></td><td><p>$$P_1 \text{ OPTIONAL } P_2$$</p></td><td><p>匹配$P_1$，并且$P_2$如果可能（评估为<code>左连接</code>）。</p></td></tr>
<tr><td><p><code>P过滤器R</code></p></td><td><p>$$P \text{ FILTER } R$$</p></td><td><p>根据条件 $R$ 限制$P$中的解。</p></td></tr>
<tr><td><p><code>GRAPH g { P }</code></p></td><td><p>$$g \text{ GRAPH } P$$</p></td><td><p>在命名图$g$中匹配模式$P$。</p></td></tr>
</tbody>
</table>

### 3. 逐步生成：SELECT示例

让我们来剖析一下你查询中提供的具体`SELECT`示例，该示例与讲义幻灯片一致。

<b>查询内容：</b>

```text
SELECT ?y
WHERE {
   _:x :borough :Berlin .                       # (tp1)
   { _:x :name ?y . }                           # (tp2)
   UNION
   { _:x :population ?z . FILTER (?z > 350000) } # (tp3 + Filter)
}
```

<b>步骤A：识别三元组模式</b>

首先，定义原子三元组模式（$tp$）：

- $$tp_1 = \_:x \text{ :borough :Berlin}$$
- $$tp_2 = \_:x \text{ :name ?y}$$
- $$tp_3 = \_:x \text{ :population ?z}$$
    
<b>步骤B：构建内部表达式（自底向上）</b>

1. <b>过滤器：</b>联合的第二部分对$tp_3$应用了一个过滤器。
    - 代数：$(tp_3 \text{ FILTER } (?z > 350000))$

2. <b>并集：</b>此过滤组与$tp_2$合并。
    - 代数：$(tp_2 \text{ UNION } (tp_3 \text{ FILTER } (?z > 350000)))$

3. <b>连接：</b>联合的结果与第一个模式连接$tp_1$（因为它们在`WHERE`子句中按顺序列出，意味着是 AND 关系）。
    - 代数：$(tp_1 \text{ JOIN } (tp_2 \text{ UNION } (tp_3 \text{ FILTER } (?z > 350000))))$
        
<b>步骤C：应用查询表单（SELECT）</b>

A `SELECT`查询在代数上被定义为形式为$SELECT_S(P)$的表达式，其中$S$是要返回的变量集，$P$是上面导出的模式。

- <b>最终表达式：</b>
    $$SELECT_{\{?y\}}(tp_1 \text{ JOIN } (tp_2 \text{ UNION } (tp_3 \text{ FILTER } (?z > 350000))))$$
    
<em>(注意：在求值过程中，</em><em>SELECT</em>运算符对应于一个<b>投影</b>，会丢弃除<em>?y</em><em>之外的所有变量。)</em>

### 4. 逐步生成：CONSTRUCT示例

`CONSTRUCT`查询有所不同，因为它们使用模板来构建一个<em>新的</em>图，而不仅仅是返回一个变量表。

<b>查询内容：</b>

```text
CONSTRUCT { ?b :country :Germany . } # Template (Q)
WHERE {
  ?b :borough :Berlin .              # Pattern (P)
}
```

<b>步骤A：识别组件</b>

- <b>图模式（</b>$P$<b>）：</b> `WHERE`子句包含单个三元组模式。
    - $$tp_1 = ?b \text{ :borough :Berlin}$$

- <b>模板 (</b>$Q$<b>)：</b> `CONSTRUCT`子句包含目标三元组。
    - $tp_2 = ?b \text{ :country :Germany}$（注意：在您的查询文本中，您将其标记为$tp2$，实际上是将其视为一个模式模板）。
        
<b>步骤B：构建表达式</b>

A `CONSTRUCT`查询被定义为形式为$CONSTRUCT(P, Q)$的表达式，其中$P$是用于匹配的图模式，$Q$是用于生成数据的三元组模板集合。

- <b>最终表达式：</b>
    $$CONSTRUCT(tp_1, \{tp_2\})$$
    
<em>(注意：在评估过程中，系统会找到所有与 *$tp_1$* 匹配的映射</em>$\mu$，并针对每个匹配项，使用这些变量实例化模板$tp_2$<em>。)</em>

### 5. 查询表单摘要

根据讲座中的定义，以下是四种主要查询形式如何转换为代数形式的：

1. <b>选择：</b> $SELECT_S(P)$
2. <b>ASK:</b> $ASK(P)$ (如果解集非空，则返回true)。
3. <b>构建：</b> $CONSTRUCT(P, Q)$
4. <b>描述：</b>（通常是特定于实现的，但一般作为一个$CONSTRUCT$，基于在$P$中找到的资源使用系统定义的模板）。

## 给定解映射，确定其中哪些对是兼容的

根据提供的讲座材料，以下是对解决方案映射兼容性、其在SPARQL评估中的作用以及实例映射相关概念的详细解释（学习目标4.3）。

### 1. 解决方案映射 ($\mu$)

A <b>解决方案映射</b>被定义为一个部分函数$\mu: V \rightarrow (U \cup B \cup L)$，它将SPARQL变量（$V$）分配给RDF术语（URI、空白节点或文字）。

- <b>定义域：</b>在一个映射中定义的变量集合称为其定义域，记为$dom(\mu)$。
- <b>示例：</b>在你的提示中，$\mu_1 = \{?borough \rightarrow :Pankow, ?berlin \rightarrow :Berlin\}$是一个解映射，其定义域为$\{?borough,?berlin\}$。
    
### 2. 定义兼容性

兼容性的概念对于像`连接`这样的操作至关重要。如果两个解决方案映射$\mu_1$和$\mu_2$对于它们之间共享的每个变量都映射到完全相同的RDF术语，则它们是<b>兼容的</b>（写为$\mu_1 \sim \mu_2$）。

<b>正式条件：</b>

$\mu_1 \sim \mu_2$如果$\forall x \in dom(\mu_1) \cap dom(\mu_2) : \mu_1(x) = \mu_2(x)$。

#### 实例分析

根据讲座幻灯片中提供的逻辑，我们可以评估你列出的配对：

- <b>兼容对：</b>
    - $$\{?x \rightarrow :Sun, \mathbf{?y \rightarrow :Earth}\}$$
    - 映射B：$\{\mathbf{?y \rightarrow :Earth}, ?z \rightarrow :Moon\}$
    - <b>推理：</b>定义域的交集为$\{?y\}$。在两个映射中，$?y$被赋值为$:Earth$。由于它们在重叠变量上一致，所以它们是<b>兼容的</b>。
        
- <b>不兼容配对：</b>
    - $$\{?x \rightarrow :Sun, \mathbf{?y \rightarrow :Earth}\}$$
    - 映射B：$\{\mathbf{?y \rightarrow :Mars}, ?z \rightarrow :Deimos\}$
    - <b>推理：</b>定义域的交集为 $\{?y\}$。然而，映射 A 赋值为 $:Earth$而映射 B 赋值为 $:Mars$。由于 $:Earth \neq :Mars$，它们<b>不兼容</b>。
        
- <b>不相交域（始终兼容）：</b>
    - $$\{?s1 \rightarrow :Mars\}$$
    - 映射B：$\{?s2 \rightarrow :Venus\}$
    - <b>推理：</b>定义域的交集为空集（$\emptyset$）。没有共享变量会导致冲突。因此，定义域不相交的解映射<b>总是兼容的</b>。
        
- <b>空映射（</b>$\mu_\emptyset$<b>）：</b>
    - 空解映射具有空定义域（$dom(\mu_\emptyset) = \emptyset$）。根据定义，它与<b>所有</b>其他解映射兼容，因为定义域的交集始终为空。
        
### 3. 应用：JOIN运算符

兼容性是SPARQL `连接`运算符使用的过滤器。在连接两组结果（$\Omega_l$和$\Omega_r$）时，代数运算符会生成一个新的集合，其中包含映射的并集$\mu_l \cup \mu_r$ <b>仅</b>适用于$\mu_l \sim \mu_r$的对。

如果$\mu_l$和$\mu_r$不兼容，则它们不能合并到单个解决方案行中，该组合将被舍弃。

### 4. 实例映射 ($\sigma$)

您的查询还引用了<b>实例映射</b>，它与解决方案映射不同，但对<b>基本图模式匹配</b>至关重要。

- <b>定义：</b>实例映射$\sigma$是从<b>空白节点</b>的一个子集到RDF术语的部分函数。
- <b>目的：</b>它处理空白节点的“存在量化”。虽然$\mu$为变量（例如`?y`）查找值，$\sigma$为查询模式中存在的空白节点（例如`_:x`）分配具体值，以查看该结构是否存在于图中。
    
<b>源示例：</b>

- <b>三元模式 (</b>$tp$<b>):</b> `_:x :name?y`
- <b>实例映射 (</b>$\sigma_1$<b>)：</b> $\{_:x \rightarrow :Neukoelln\}$
- <b>解决方案映射（</b>$\mu_1$<b>）：</b> $\{?y \rightarrow "Neukoelln"@en\}$
    
为了检查这是否与图表匹配，系统会应用这两种映射：

1. 应用 $\sigma$：`_:x`变为`:Neukoelln`。模式变为`:Neukoelln :name?y`。
2. 应用 $\mu$: `?y`变为`"Neukoelln"@en`。
3. <b>结果：</b> `:Neukoelln :名称 "Neukoelln"@en`。

如果这个三元组存在于图$G$中，那么模式匹配。

## 模式匹配

根据讲座材料中提供的详细查询评估逻辑，以下是对<b>基本图模式（BGP）匹配</b>的解释。这个过程是SPARQL引擎确定数据集的哪些部分与`WHERE`子句中定义的标准相匹配的基本步骤。

### 1. 核心概念

一个<b>基本图模式（BGP）</b>由一组三元组模式组成。如果引擎可以找到模式中$P$<b>空白节点</b>$G$和<b>变量</b>的特定替换，使得生成的三元组实际上存在于图$G$中，则BGP匹配一个RDF图。

为了将其形式化，需要两个不同的映射函数：

1. $\sigma$<b> (Sigma):</b>一个<b> RDF实例映射</b>。它将查询中的<b>空白节点</b>映射到数据集中的RDF术语（URI、文字或空白节点）。
2. $\mu$<b>(Mu):</b>一个<b>解决方案映射</b>。它将查询中的<b>变量</b>映射到RDF术语。
    
### 2. 匹配的三个条件

要使一个解有效，它必须满足关于定义域和图结构的三个特定条件。让我们用你的具体例子来分析这些条件：

- <b>模式 (</b>$tp_1$<b>):</b> `_:x :name?y`
- <b>图表（</b>$G$<b>）：</b>包含`：Neukoelln :名称 "Neukoelln"@en`
    
#### 条件1：空白节点域覆盖范围

实例映射的定义域$\sigma$必须与三元组模式（$bn(tp)$）中的空白节点集完全匹配。

- <b>要求：</b>模式`_:x :name?y`包含一个空白节点：`_:x`。因此，$\sigma$必须为`_:x`提供映射。
- <b>你的示例：</b> $\sigma_1 = \{ \_:x \rightarrow :Neukoelln \}$。
- <b>结果：</b> `dom(σ1) = { _:x }`。条件已满足。
    
#### 条件2：可变域覆盖

解映射的定义域$\mu$必须与三元模式中的变量集（$vars(tp)$）完全匹配。

- <b>要求：</b>模式包含一个变量：`?y`。因此，$\mu$必须为`?y`提供一个绑定。
- <b>你的示例：</b> $\mu_1 = \{?y \rightarrow "Neukoelln"@en \}$。
- <b>结果：</b> `dom(µ1) = {?y }`。条件已满足。
    
#### 条件3：子图验证

这是最关键的一步。如果我们将空白节点映射$\sigma$应用于模式，然后将解决方案映射$\mu$应用于该结果，那么最终的三元组集合必须存在于数据集$G$中。

数学上：$\mu(\sigma(tp)) \subseteq G$。

- <b>步骤A（应用</b>$\sigma$<b>）：</b>

将`_:x`替换为`:Neukoelln`。

$$\sigma_1(tp_1) = :Neukoelln :name ?y$$

- <b>步骤B（应用</b>$\mu$<b>）：</b>

将`?y`替换为`"Neukoelln"@en`。

$$\mu_1(\sigma_1(tp_1)) = :Neukoelln :name "Neukoelln"@en$$

- <b>步骤C（检查图表）：</b>

三元组`:Neukoelln :name "Neukoelln"@en`是否存在于图$G$中？

<b>是的。</b>因此，模式匹配。

### 3. 匹配的精确性（词法空间与值空间）

请注意您的评论：<em>"子图是按字面意思理解的。"</em>

在SPARQL<b>模式匹配</b>中，比较操作在<b>词法空间</b>中进行。术语必须逐字符完全相同才能匹配。这与<b>FILTER</b>评估不同，后者通常在<b>值空间</b>中操作。

- <b>模式匹配示例：</b>如果图中包含整数`"01"^^xsd:integer`，而你查询的是`"1"^^xsd:integer`，<b>模式匹配将失败</b>，因为字符串"01"和"1"在词法上并不相同。
- <b>过滤示例：</b>如果使用`FILTER(?x = 1)`，则会成功，因为过滤器会计算数值<em>值</em>（其中$1 = 01$）。

## 在给定的RDF数据集上评估SPARQL代数表达式

根据讲座内容，以下是对在RDF数据集上评估SPARQL代数表达式的详细解释，特别关注`JOIN`、`FILTER`、`SELECT`和`CONSTRUCT`操作（学习目标5.4）。

### 1. 总体评估逻辑

SPARQL查询的求值由`eval()`函数处理。该函数接受一个代数表达式，并将其递归地转换为对<b>解映射</b>$D$

- <b>输入：</b>一个代数表达式。
- <b>输出：</b>一组解决方案映射（或者在`CONSTRUCT`的情况下为RDF图）。
    
### 2. 评估图模式（WHERE子句）

#### A. JOIN表达式

要计算像`P1 JOIN P2`这样的表达式，系统会遵循以下步骤：

1. <b>计算P1：</b>计算$\Omega_1 = eval(D(G), P1)$。
2. <b>计算P2：</b>计算$\Omega_2 = eval(D(G), P2)$。
3. <b>合并兼容映射：</b>结果是所有映射的集合$\mu_1 \cup \mu_2$其中$\mu_1 \in \Omega_1$和$\mu_2 \in \Omega_2$是<b>兼容的</b>。
    - <i>兼容性：</i>如果两个映射对于它们共有的每个变量都具有相同的值，则它们是兼容的（例如，如果两者都定义了`?p`，`?p`必须匹配）。
        
<b>示例：</b>

使用来自以下来源的卫星数据：

- $\Omega_1$(来自`?p :卫星?s1`)产生`{?p->:地球,?s1->:月球}`。
- $\Omega_2$(来自`?p :卫星?s2`)产生`{?p->:地球,?s2->:月球}`。
- 由于`?p`匹配（`:Earth`），这些连接形成`{?p->:Earth,?s1->:Moon,?s2->:Moon}`。
    
#### B. FILTER表达式

为了评估` Filter(R, Ω)`，系统会获取$\Omega$（由连接或模式匹配生成的）解映射集，并应用布尔条件$R$。

- <b>过程：</b>对于每个映射$\mu \in \Omega$，条件$R(\mu)$都会被评估。
- <b>结果：</b>仅保留$R(\mu)$计算结果为<b>TRUE</b>的映射。
    
<b>示例：</b>

如果条件是`?s1!=?s2`，并且我们有一个映射`{?s1->:Moon,?s2->:Moon}`，则该条件为假。此映射将被丢弃。然而，`{?s1->:Phobos,?s2->:Deimos}`的计算结果为真，因此被保留。

---

### 3. 评估查询表单

#### A. SELECT表达式

A `SELECT`查询被评估为一个<b>投影</b>。

- <b>定义：</b> $eval(D(G), SELECT_S(P)) := Projection(S, eval(D(G), P))$ 。
- <b>过程：</b>在评估图模式$P$以得到$\Omega$之后，系统仅投影出集合$S$中指定的变量（`SELECT`行中的变量）。
- <b>语义：</b>如果作为集合处理，重复项会自动删除。如果作为包（多重集）处理，重复项会保留，除非指定了`DISTINCT`。
    
#### B. ASK表达式

一个`ASK`查询返回一个布尔值。

- <b>过程：</b>它检查由图模式产生的解映射集合是否为空。
- <b>结果：</b>如果 $\Omega \neq \emptyset$，则返回`true`，否则返回`false`。
    
---

### 4. 评估 CONSTRUCT 表达式

`CONSTRUCT` 形式是独一无二的，因为它生成的是一个新的 <b>RDF 图</b> ，而不是一个解决方案表。

<b>公式：</b> $eval(D(G), CONSTRUCT(P, Q)) := \bigcup \{ Inst(\mu, Q) \mid \forall \mu \in eval(D(G), P) \}$。

这涉及两个阶段：

1. <b>模式匹配：</b>计算`WHERE`子句（$P$）以获得解映射$\Omega$。
2. <b>模板实例化：</b>对于<b>每个</b>解映射$\mu$在$\Omega$中，将值应用于模板$Q$。
    
#### 卫星示例详细演练

<b>查询内容：</b>

- <b>模式 (</b>$P_1$<b>):</b> `?p :卫星?s1`
- <b>模板 (</b>$Q_1$<b>):</b> `{?s1 rdf:type :Satellite.?s1 :orbitAround _:x }`
    
<b>步骤1：计算P1的解（</b>$\Omega_1$<b>）</b>

基于数据集$D(G)$，解决方案如下：

- $\mu_1$: `{?p -> :地球,?s1 -> :月球}`
- $\mu_2$: `{?p -> :火星,?s1 -> :火卫一}`
- $\mu_3$: `{?p -> :火星,?s1 -> :火卫二}`.
    
<b>步骤2：实例化模板（</b>$G'$<b>）</b>

系统会遍历$\Omega_1$并填充$Q_1$。`CONSTRUCT`的一个关键规则是<b>模板中的空白节点会为每个解决方案映射生成新的空白节点</b>。

- <b>处理</b>$\mu_1$<b> (:月亮):</b>
    - 将`?s1`替换为`:Moon`。
    - 将`_:x`替换为一个新的空白节点`_:x1`。
    - <i>三元组：</i> `:Moon rdf:type :Satellite. :Moon :orbitAround _:x1.`

- <b>处理</b>$\mu_2$<b> (:火卫一):</b>
    - 将`?s1`替换为`:Phobos`。
    - 将`_:x`替换为一个新的空白节点`_:x2`。
    - <i>三元组：</i> `:火卫一 rdf:type :卫星 。 :火卫一 :环绕运行 _:x2 。`

- <b>处理</b>$\mu_3$<b> (:Deimos):</b>
    - 将`?s1`替换为`:Deimos`。
    - 将`_:x`替换为一个新的空白节点`_:x3`。
    - <i>三元组：</i> `:Deimos rdf:type :Satellite. :Deimos :orbitAround _:x3.`
        
<b>最终结果 (</b>$G'$<b>):</b>

这些三元组的并集构成了结果图，其中每个卫星都围绕一个唯一的、新生成的空白节点实体运行。

